mod common;

use common::{
    AccessControlServerProcess, ServerProcess, start_server, start_server_with_access_control,
};
use reqwest::StatusCode;
use reqwest::blocking::Client;
use rstest::rstest;
use torc::client::{Configuration, default_api};
use torc::models;

/// Helper to create a config with basic auth
fn config_with_auth(base_config: &Configuration, username: &str) -> Configuration {
    Configuration {
        base_path: base_config.base_path.clone(),
        user_agent: base_config.user_agent.clone(),
        client: base_config.client.clone(),
        basic_auth: Some((username.to_string(), Some("password".to_string()))),
        oauth_access_token: None,
        bearer_access_token: None,
        api_key: None,
    }
}

/// Create a workflow with a specific user
fn create_workflow_with_user(
    config: &Configuration,
    name: &str,
    user: &str,
) -> models::WorkflowModel {
    let workflow = models::WorkflowModel::new(name.to_string(), user.to_string());
    default_api::create_workflow(config, workflow).expect("Failed to create workflow")
}

// ============================================================================
// SSE Events Stream Tests (without access control)
// ============================================================================

#[rstest]
fn test_sse_stream_endpoint_exists(start_server: &ServerProcess) {
    let config = &start_server.config;

    // Create a workflow
    let workflow = create_workflow_with_user(config, "sse-test-workflow", "test_user");
    let workflow_id = workflow.id.unwrap();

    // Try to connect to SSE endpoint
    let client = Client::new();
    let url = format!(
        "{}/workflows/{}/events/stream",
        config.base_path, workflow_id
    );

    let response = client
        .get(&url)
        .header("Accept", "text/event-stream")
        .timeout(std::time::Duration::from_secs(2))
        .send();

    // The request should succeed (200 OK) - it may timeout on the body read
    // since it's a streaming response, but the initial response should be OK
    match response {
        Ok(resp) => {
            assert_eq!(
                resp.status(),
                StatusCode::OK,
                "SSE endpoint should return 200 OK"
            );
            assert!(
                resp.headers()
                    .get("content-type")
                    .map(|v| v.to_str().unwrap_or(""))
                    .unwrap_or("")
                    .contains("text/event-stream"),
                "Content-Type should be text/event-stream"
            );
        }
        Err(e) => {
            // Timeout is acceptable since we're not reading the stream
            if !e.is_timeout() {
                panic!("Unexpected error connecting to SSE endpoint: {:?}", e);
            }
        }
    }
}

#[rstest]
fn test_sse_stream_404_for_nonexistent_workflow(start_server: &ServerProcess) {
    let config = &start_server.config;

    // Try to connect to SSE endpoint for a non-existent workflow
    let client = Client::new();
    let url = format!("{}/workflows/999999/events/stream", config.base_path);

    let response = client
        .get(&url)
        .header("Accept", "text/event-stream")
        .timeout(std::time::Duration::from_secs(5))
        .send()
        .expect("Failed to send request");

    assert_eq!(
        response.status(),
        StatusCode::NOT_FOUND,
        "SSE endpoint should return 404 for non-existent workflow"
    );
}

// ============================================================================
// SSE Events Stream Tests (with access control)
// ============================================================================

#[rstest]
fn test_sse_stream_authorized_user(start_server_with_access_control: &AccessControlServerProcess) {
    let config = &start_server_with_access_control.config;

    // Create a workflow owned by alice
    let alice_config = config_with_auth(config, "alice");
    let workflow = create_workflow_with_user(&alice_config, "alice-sse-workflow", "alice");
    let workflow_id = workflow.id.unwrap();

    // Alice should be able to access SSE endpoint for her own workflow
    let client = Client::new();
    let url = format!(
        "{}/workflows/{}/events/stream",
        config.base_path, workflow_id
    );

    let response = client
        .get(&url)
        .basic_auth("alice", Some("password"))
        .header("Accept", "text/event-stream")
        .timeout(std::time::Duration::from_secs(2))
        .send();

    match response {
        Ok(resp) => {
            assert_eq!(
                resp.status(),
                StatusCode::OK,
                "Owner should be able to access SSE endpoint"
            );
        }
        Err(e) => {
            // Timeout is acceptable since we're not reading the stream
            if !e.is_timeout() {
                panic!("Unexpected error for authorized user: {:?}", e);
            }
        }
    }
}

#[rstest]
fn test_sse_stream_unauthorized_user(
    start_server_with_access_control: &AccessControlServerProcess,
) {
    let config = &start_server_with_access_control.config;

    // Create a workflow owned by alice
    let alice_config = config_with_auth(config, "alice");
    let workflow = create_workflow_with_user(&alice_config, "alice-private-workflow", "alice");
    let workflow_id = workflow.id.unwrap();

    // Bob should NOT be able to access SSE endpoint for alice's workflow
    let client = Client::new();
    let url = format!(
        "{}/workflows/{}/events/stream",
        config.base_path, workflow_id
    );

    let response = client
        .get(&url)
        .basic_auth("bob", Some("password"))
        .header("Accept", "text/event-stream")
        .timeout(std::time::Duration::from_secs(5))
        .send()
        .expect("Failed to send request");

    assert_eq!(
        response.status(),
        StatusCode::FORBIDDEN,
        "Unauthorized user should get 403 Forbidden"
    );
}

#[rstest]
fn test_sse_stream_shared_workflow_access(
    start_server_with_access_control: &AccessControlServerProcess,
) {
    let config = &start_server_with_access_control.config;

    // Create a group and add bob to it
    let group = models::AccessGroupModel {
        id: None,
        name: "sse-test-group".to_string(),
        description: Some("Test group for SSE".to_string()),
        created_at: None,
    };
    let group = default_api::create_access_group(config, group).expect("Failed to create group");
    let group_id = group.id.unwrap();

    // Add bob to the group
    let membership = models::UserGroupMembershipModel {
        id: None,
        user_name: "bob".to_string(),
        group_id,
        role: "member".to_string(),
        created_at: None,
    };
    default_api::add_user_to_group(config, group_id, membership)
        .expect("Failed to add bob to group");

    // Create a workflow owned by alice
    let alice_config = config_with_auth(config, "alice");
    let workflow = create_workflow_with_user(&alice_config, "shared-sse-workflow", "alice");
    let workflow_id = workflow.id.unwrap();

    // Share the workflow with the group
    default_api::add_workflow_to_group(config, workflow_id, group_id)
        .expect("Failed to share workflow");

    // Bob (group member) should now be able to access SSE endpoint
    let client = Client::new();
    let url = format!(
        "{}/workflows/{}/events/stream",
        config.base_path, workflow_id
    );

    let response = client
        .get(&url)
        .basic_auth("bob", Some("password"))
        .header("Accept", "text/event-stream")
        .timeout(std::time::Duration::from_secs(2))
        .send();

    match response {
        Ok(resp) => {
            assert_eq!(
                resp.status(),
                StatusCode::OK,
                "Group member should be able to access shared workflow's SSE endpoint"
            );
        }
        Err(e) => {
            // Timeout is acceptable since we're not reading the stream
            if !e.is_timeout() {
                panic!("Unexpected error for group member: {:?}", e);
            }
        }
    }

    // Carol (not in group) should still NOT be able to access
    let response = client
        .get(&url)
        .basic_auth("carol", Some("password"))
        .header("Accept", "text/event-stream")
        .timeout(std::time::Duration::from_secs(5))
        .send()
        .expect("Failed to send request");

    assert_eq!(
        response.status(),
        StatusCode::FORBIDDEN,
        "Non-group member should get 403 Forbidden"
    );
}
