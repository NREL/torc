# coding: utf-8

"""
    torc

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v0.2.8
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_call, ValidationError
from typing import Dict, List, Optional, Tuple

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictBool, StrictFloat, StrictInt, StrictStr, field_validator

from typing import Any, Dict, List, Optional, Union

from torc.openapi_client.models.aws_schedulers_model import AwsSchedulersModel
from torc.openapi_client.models.bulk_jobs_model import BulkJobsModel
from torc.openapi_client.models.compute_node_stats_model import ComputeNodeStatsModel
from torc.openapi_client.models.compute_nodes_model import ComputeNodesModel
from torc.openapi_client.models.compute_nodes_resources import ComputeNodesResources
from torc.openapi_client.models.edges_name_model import EdgesNameModel
from torc.openapi_client.models.files_model import FilesModel
from torc.openapi_client.models.get_aws_schedulers_response import GetAwsSchedulersResponse
from torc.openapi_client.models.get_compute_node_stats_response import GetComputeNodeStatsResponse
from torc.openapi_client.models.get_compute_nodes_response import GetComputeNodesResponse
from torc.openapi_client.models.get_edges_name_response import GetEdgesNameResponse
from torc.openapi_client.models.get_events_response import GetEventsResponse
from torc.openapi_client.models.get_files_produced_by_job_key_response import GetFilesProducedByJobKeyResponse
from torc.openapi_client.models.get_files_response import GetFilesResponse
from torc.openapi_client.models.get_job_process_stats_response import GetJobProcessStatsResponse
from torc.openapi_client.models.get_job_specifications_response import GetJobSpecificationsResponse
from torc.openapi_client.models.get_jobs_find_by_needs_file_key_response import GetJobsFindByNeedsFileKeyResponse
from torc.openapi_client.models.get_jobs_find_by_status_status_response import GetJobsFindByStatusStatusResponse
from torc.openapi_client.models.get_jobs_key_user_data_consumes_response import GetJobsKeyUserDataConsumesResponse
from torc.openapi_client.models.get_jobs_key_user_data_stores_response import GetJobsKeyUserDataStoresResponse
from torc.openapi_client.models.get_jobs_response import GetJobsResponse
from torc.openapi_client.models.get_local_schedulers_response import GetLocalSchedulersResponse
from torc.openapi_client.models.get_resource_requirements_response import GetResourceRequirementsResponse
from torc.openapi_client.models.get_results_response import GetResultsResponse
from torc.openapi_client.models.get_scheduled_compute_nodes_response import GetScheduledComputeNodesResponse
from torc.openapi_client.models.get_slurm_schedulers_response import GetSlurmSchedulersResponse
from torc.openapi_client.models.get_user_data_response import GetUserDataResponse
from torc.openapi_client.models.get_workflows_key_collection_names_response import GetWorkflowsKeyCollectionNamesResponse
from torc.openapi_client.models.get_workflows_key_dot_graph_name_response import GetWorkflowsKeyDotGraphNameResponse
from torc.openapi_client.models.get_workflows_key_is_complete_response import GetWorkflowsKeyIsCompleteResponse
from torc.openapi_client.models.get_workflows_key_missing_user_data_response import GetWorkflowsKeyMissingUserDataResponse
from torc.openapi_client.models.get_workflows_key_ready_job_requirements_response import GetWorkflowsKeyReadyJobRequirementsResponse
from torc.openapi_client.models.get_workflows_key_required_existing_files_response import GetWorkflowsKeyRequiredExistingFilesResponse
from torc.openapi_client.models.get_workflows_response import GetWorkflowsResponse
from torc.openapi_client.models.job_process_stats_model import JobProcessStatsModel
from torc.openapi_client.models.job_specifications_model import JobSpecificationsModel
from torc.openapi_client.models.jobs_model import JobsModel
from torc.openapi_client.models.local_schedulers_model import LocalSchedulersModel
from torc.openapi_client.models.post_workflows_key_join_by_inbound_edge_collection_edge_response import PostWorkflowsKeyJoinByInboundEdgeCollectionEdgeResponse
from torc.openapi_client.models.post_workflows_key_join_by_outbound_edge_collection_edge_response import PostWorkflowsKeyJoinByOutboundEdgeCollectionEdgeResponse
from torc.openapi_client.models.post_workflows_key_prepare_jobs_for_scheduling_response import PostWorkflowsKeyPrepareJobsForSchedulingResponse
from torc.openapi_client.models.post_workflows_key_prepare_jobs_for_submission_response import PostWorkflowsKeyPrepareJobsForSubmissionResponse
from torc.openapi_client.models.post_workflows_key_prepare_next_jobs_for_submission_response import PostWorkflowsKeyPrepareNextJobsForSubmissionResponse
from torc.openapi_client.models.post_workflows_key_process_changed_job_inputs_response import PostWorkflowsKeyProcessChangedJobInputsResponse
from torc.openapi_client.models.resource_requirements_model import ResourceRequirementsModel
from torc.openapi_client.models.results_model import ResultsModel
from torc.openapi_client.models.scheduled_compute_nodes_model import ScheduledComputeNodesModel
from torc.openapi_client.models.slurm_schedulers_model import SlurmSchedulersModel
from torc.openapi_client.models.user_data_model import UserDataModel
from torc.openapi_client.models.workflow_config_model import WorkflowConfigModel
from torc.openapi_client.models.workflow_specifications_model import WorkflowSpecificationsModel
from torc.openapi_client.models.workflow_status_model import WorkflowStatusModel
from torc.openapi_client.models.workflows_model import WorkflowsModel

from torc.openapi_client.api_client import ApiClient
from torc.openapi_client.api_response import ApiResponse
from torc.openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def delete_workflows_key(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> WorkflowsModel:
        """Delete a workflow  # noqa: E501

        Deletes a document from the \"workflows\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_key(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_key_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a workflow  # noqa: E501

        Deletes a document from the \"workflows\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_key_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_aws_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type AWS compute node configuration for a workflow  # noqa: E501

        Delete all documents from the \"aws_schedulers\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_aws_schedulers(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_aws_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_aws_schedulers_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_aws_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type AWS compute node configuration for a workflow  # noqa: E501

        Delete all documents from the \"aws_schedulers\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_aws_schedulers_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_aws_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/aws_schedulers', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_aws_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the AWS compute node configuration document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> AwsSchedulersModel:
        """Delete a document of type AWS compute node configuration  # noqa: E501

        Deletes a document from the \"aws_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_aws_schedulers_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the AWS compute node configuration document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AwsSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_aws_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_aws_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_aws_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the AWS compute node configuration document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type AWS compute node configuration  # noqa: E501

        Deletes a document from the \"aws_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_aws_schedulers_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the AWS compute node configuration document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AwsSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_aws_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AwsSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/aws_schedulers/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_compute_node_stats(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type compute node statistics for a workflow  # noqa: E501

        Delete all documents from the \"compute_node_stats\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_node_stats(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_compute_node_stats_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_compute_node_stats_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_compute_node_stats_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type compute node statistics for a workflow  # noqa: E501

        Delete all documents from the \"compute_node_stats\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_node_stats_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_compute_node_stats" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_node_stats', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_compute_node_stats_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute node statistics document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ComputeNodeStatsModel:
        """Delete a document of type compute node statistics  # noqa: E501

        Deletes a document from the \"compute_node_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_node_stats_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute node statistics document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodeStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_compute_node_stats_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_compute_node_stats_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_compute_node_stats_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute node statistics document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type compute node statistics  # noqa: E501

        Deletes a document from the \"compute_node_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_node_stats_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute node statistics document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodeStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_compute_node_stats_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodeStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_node_stats/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_compute_nodes(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type compute node for a workflow  # noqa: E501

        Delete all documents from the \"compute_nodes\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_nodes(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_compute_nodes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_compute_nodes_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_compute_nodes_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type compute node for a workflow  # noqa: E501

        Delete all documents from the \"compute_nodes\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_nodes_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_compute_nodes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_nodes', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_compute_nodes_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute node document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ComputeNodesModel:
        """Delete a document of type compute node  # noqa: E501

        Deletes a document from the \"compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_nodes_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute node document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_compute_nodes_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_compute_nodes_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_compute_nodes_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute node document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type compute node  # noqa: E501

        Deletes a document from the \"compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_compute_nodes_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute node document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_compute_nodes_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_nodes/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_edges_name(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge collection name")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all edges from the designated collection  # noqa: E501

        Deletes all edges from the designated collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_edges_name(workflow, name, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge collection name (required)
        :type name: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_edges_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_edges_name_with_http_info.raw_function(
            workflow,
            name,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_edges_name_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge collection name")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all edges from the designated collection  # noqa: E501

        Deletes all edges from the designated collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_edges_name_with_http_info(workflow, name, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge collection name (required)
        :type name: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'name',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_edges_name" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/edges/{name}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_edges_name_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge name.")],
        key: Annotated[StrictStr, Field(description="Edge key.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> EdgesNameModel:
        """Delete an edge  # noqa: E501

        Deletes an edge from the designated collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_edges_name_key(workflow, name, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge name. (required)
        :type name: str
        :param key: Edge key. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EdgesNameModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_edges_name_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_edges_name_key_with_http_info.raw_function(
            workflow,
            name,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_edges_name_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge name.")],
        key: Annotated[StrictStr, Field(description="Edge key.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete an edge  # noqa: E501

        Deletes an edge from the designated collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_edges_name_key_with_http_info(workflow, name, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge name. (required)
        :type name: str
        :param key: Edge key. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EdgesNameModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'name',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_edges_name_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['name'] is not None:
            _path_params['name'] = _params['name']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EdgesNameModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/edges/{name}/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_events(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type event for a workflow  # noqa: E501

        Delete all documents from the \"events\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_events(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_events_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_events_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_events_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type event for a workflow  # noqa: E501

        Delete all documents from the \"events\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_events_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_events" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/events', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_events_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the event document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete a document of type event  # noqa: E501

        Deletes a document from the \"events\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_events_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the event document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_events_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_events_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_events_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the event document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type event  # noqa: E501

        Deletes a document from the \"events\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_events_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the event document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_events_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/events/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_files(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type file for a workflow  # noqa: E501

        Delete all documents from the \"files\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_files(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_files_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_files_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type file for a workflow  # noqa: E501

        Delete all documents from the \"files\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_files_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/files', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_files_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the file document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> FilesModel:
        """Delete a document of type file  # noqa: E501

        Deletes a document from the \"files\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_files_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the file document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FilesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_files_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_files_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_files_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the file document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type file  # noqa: E501

        Deletes a document from the \"files\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_files_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the file document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FilesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_files_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/files/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_job_process_stats(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type job process statistics for a workflow  # noqa: E501

        Delete all documents from the \"job_process_stats\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_job_process_stats(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_job_process_stats_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_job_process_stats_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_job_process_stats_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type job process statistics for a workflow  # noqa: E501

        Delete all documents from the \"job_process_stats\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_job_process_stats_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_job_process_stats" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_process_stats', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_job_process_stats_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the job process statistics document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> JobProcessStatsModel:
        """Delete a document of type job process statistics  # noqa: E501

        Deletes a document from the \"job_process_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_job_process_stats_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the job process statistics document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobProcessStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_job_process_stats_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_job_process_stats_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_job_process_stats_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the job process statistics document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type job process statistics  # noqa: E501

        Deletes a document from the \"job_process_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_job_process_stats_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the job process statistics document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobProcessStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_job_process_stats_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobProcessStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_process_stats/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_jobs(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type job for a workflow  # noqa: E501

        Delete all documents from the \"jobs\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_jobs(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_jobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_jobs_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_jobs_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type job for a workflow  # noqa: E501

        Delete all documents from the \"jobs\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_jobs_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_jobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_jobs_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the job document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> JobsModel:
        """Delete a document of type job  # noqa: E501

        Deletes a document from the \"jobs\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_jobs_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the job document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_jobs_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_jobs_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_jobs_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the job document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type job  # noqa: E501

        Deletes a document from the \"jobs\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_jobs_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the job document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_jobs_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_local_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type local compute node configuration for a workflow  # noqa: E501

        Delete all documents from the \"local_schedulers\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_local_schedulers(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_local_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_local_schedulers_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_local_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type local compute node configuration for a workflow  # noqa: E501

        Delete all documents from the \"local_schedulers\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_local_schedulers_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_local_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/local_schedulers', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_local_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the local compute node configuration document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> LocalSchedulersModel:
        """Delete a document of type local compute node configuration  # noqa: E501

        Deletes a document from the \"local_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_local_schedulers_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the local compute node configuration document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LocalSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_local_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_local_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_local_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the local compute node configuration document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type local compute node configuration  # noqa: E501

        Deletes a document from the \"local_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_local_schedulers_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the local compute node configuration document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LocalSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_local_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/local_schedulers/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_resource_requirements(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type resource requirements for a workflow  # noqa: E501

        Delete all documents from the \"resource_requirements\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_resource_requirements(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_resource_requirements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_resource_requirements_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_resource_requirements_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type resource requirements for a workflow  # noqa: E501

        Delete all documents from the \"resource_requirements\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_resource_requirements_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_resource_requirements" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/resource_requirements', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_resource_requirements_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the resource requirements document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ResourceRequirementsModel:
        """Delete a document of type resource requirements  # noqa: E501

        Deletes a document from the \"resource_requirements\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_resource_requirements_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the resource requirements document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResourceRequirementsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_resource_requirements_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_resource_requirements_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_resource_requirements_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the resource requirements document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type resource requirements  # noqa: E501

        Deletes a document from the \"resource_requirements\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_resource_requirements_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the resource requirements document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResourceRequirementsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_resource_requirements_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRequirementsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/resource_requirements/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_results(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type result for a workflow  # noqa: E501

        Delete all documents from the \"results\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_results(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_results_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_results_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_results_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type result for a workflow  # noqa: E501

        Delete all documents from the \"results\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_results_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_results" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/results', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_results_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the result document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ResultsModel:
        """Delete a document of type result  # noqa: E501

        Deletes a document from the \"results\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_results_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the result document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResultsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_results_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_results_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_results_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the result document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type result  # noqa: E501

        Deletes a document from the \"results\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_results_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the result document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResultsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_results_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/results/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_scheduled_compute_nodes(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type scheduled compute node for a workflow  # noqa: E501

        Delete all documents from the \"scheduled_compute_nodes\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_scheduled_compute_nodes(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_scheduled_compute_nodes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_scheduled_compute_nodes_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_scheduled_compute_nodes_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type scheduled compute node for a workflow  # noqa: E501

        Delete all documents from the \"scheduled_compute_nodes\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_scheduled_compute_nodes_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_scheduled_compute_nodes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/scheduled_compute_nodes', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_scheduled_compute_nodes_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the scheduled compute node document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ScheduledComputeNodesModel:
        """Delete a document of type scheduled compute node  # noqa: E501

        Deletes a document from the \"scheduled_compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_scheduled_compute_nodes_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the scheduled compute node document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ScheduledComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_scheduled_compute_nodes_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_scheduled_compute_nodes_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_scheduled_compute_nodes_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the scheduled compute node document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type scheduled compute node  # noqa: E501

        Deletes a document from the \"scheduled_compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_scheduled_compute_nodes_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the scheduled compute node document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ScheduledComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_scheduled_compute_nodes_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/scheduled_compute_nodes/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_slurm_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type Slurm compute node configuration for a workflow  # noqa: E501

        Delete all documents from the \"slurm_schedulers\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_slurm_schedulers(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_slurm_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_slurm_schedulers_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_slurm_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type Slurm compute node configuration for a workflow  # noqa: E501

        Delete all documents from the \"slurm_schedulers\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_slurm_schedulers_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_slurm_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/slurm_schedulers', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_slurm_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the Slurm compute node configuration document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> SlurmSchedulersModel:
        """Delete a document of type Slurm compute node configuration  # noqa: E501

        Deletes a document from the \"slurm_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_slurm_schedulers_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the Slurm compute node configuration document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SlurmSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_slurm_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_slurm_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_slurm_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the Slurm compute node configuration document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type Slurm compute node configuration  # noqa: E501

        Deletes a document from the \"slurm_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_slurm_schedulers_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the Slurm compute node configuration document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SlurmSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_slurm_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SlurmSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/slurm_schedulers/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_user_data(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Delete all documents of type user data for a workflow  # noqa: E501

        Delete all documents from the \"user_data\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_user_data(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_user_data_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_user_data_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_user_data_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete all documents of type user data for a workflow  # noqa: E501

        Delete all documents from the \"user_data\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_user_data_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_user_data" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/user_data', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def delete_workflows_workflow_user_data_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the user data document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> UserDataModel:
        """Delete a document of type user data  # noqa: E501

        Deletes a document from the \"user_data\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_user_data_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the user data document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDataModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_workflows_workflow_user_data_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_workflows_workflow_user_data_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def delete_workflows_workflow_user_data_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the user data document.")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Delete a document of type user data  # noqa: E501

        Deletes a document from the \"user_data\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflows_workflow_user_data_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the user data document. (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDataModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflows_workflow_user_data_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDataModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/user_data/{key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_aws_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetAwsSchedulersResponse:
        """Retrieve all AWS compute node configuration documents  # noqa: E501

        Retrieve all documents from the \"aws_schedulers\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_aws_schedulers(workflow, skip, limit, sort_by, reverse_sort, key, name, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetAwsSchedulersResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_aws_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_aws_schedulers_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            name,
            **kwargs,
        )

    @validate_call
    def get_aws_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all AWS compute node configuration documents  # noqa: E501

        Retrieve all documents from the \"aws_schedulers\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_aws_schedulers_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, name, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetAwsSchedulersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aws_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAwsSchedulersResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/aws_schedulers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_aws_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the aws_schedulers document")],
        **kwargs,
    ) -> AwsSchedulersModel:
        """Retrieve the AWS compute node configuration for a key.  # noqa: E501

        Retrieve the document from the \"aws_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_aws_schedulers_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the aws_schedulers document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AwsSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_aws_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_aws_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_aws_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the aws_schedulers document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the AWS compute node configuration for a key.  # noqa: E501

        Retrieve the document from the \"aws_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_aws_schedulers_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the aws_schedulers document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AwsSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aws_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AwsSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/aws_schedulers/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_compute_node_stats(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        hostname: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetComputeNodeStatsResponse:
        """Retrieve all compute node statistics documents  # noqa: E501

        Retrieve all documents from the \"compute_node_stats\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_node_stats(workflow, skip, limit, sort_by, reverse_sort, key, hostname, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param hostname:
        :type hostname: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetComputeNodeStatsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_compute_node_stats_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_compute_node_stats_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            hostname,
            **kwargs,
        )

    @validate_call
    def get_compute_node_stats_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        hostname: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all compute node statistics documents  # noqa: E501

        Retrieve all documents from the \"compute_node_stats\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_node_stats_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, hostname, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param hostname:
        :type hostname: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetComputeNodeStatsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'hostname'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_node_stats" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('hostname') is not None:  # noqa: E501
            _query_params.append(('hostname', _params['hostname']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetComputeNodeStatsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_node_stats', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_compute_node_stats_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute_node_stats document")],
        **kwargs,
    ) -> ComputeNodeStatsModel:
        """Retrieve the compute node statistics for a key.  # noqa: E501

        Retrieve the document from the \"compute_node_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_node_stats_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute_node_stats document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodeStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_compute_node_stats_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_compute_node_stats_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_compute_node_stats_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute_node_stats document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the compute node statistics for a key.  # noqa: E501

        Retrieve the document from the \"compute_node_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_node_stats_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute_node_stats document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodeStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_node_stats_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodeStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_node_stats/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_compute_nodes(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        hostname: Optional[StrictStr] = None,
        is_active: Optional[StrictBool] = None,
        **kwargs,
    ) -> GetComputeNodesResponse:
        """Retrieve all compute node documents  # noqa: E501

        Retrieve all documents from the \"compute_nodes\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_nodes(workflow, skip, limit, sort_by, reverse_sort, key, hostname, is_active, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param hostname:
        :type hostname: str
        :param is_active:
        :type is_active: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetComputeNodesResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_compute_nodes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_compute_nodes_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            hostname,
            is_active,
            **kwargs,
        )

    @validate_call
    def get_compute_nodes_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        hostname: Optional[StrictStr] = None,
        is_active: Optional[StrictBool] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all compute node documents  # noqa: E501

        Retrieve all documents from the \"compute_nodes\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_nodes_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, hostname, is_active, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param hostname:
        :type hostname: str
        :param is_active:
        :type is_active: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetComputeNodesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'hostname',
            'is_active'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_nodes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('hostname') is not None:  # noqa: E501
            _query_params.append(('hostname', _params['hostname']))

        if _params.get('is_active') is not None:  # noqa: E501
            _query_params.append(('is_active', _params['is_active']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetComputeNodesResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_nodes', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_compute_nodes_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute_nodes document")],
        **kwargs,
    ) -> ComputeNodesModel:
        """Retrieve the compute node for a key.  # noqa: E501

        Retrieve the document from the \"compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_nodes_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute_nodes document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_compute_nodes_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_compute_nodes_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_compute_nodes_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the compute_nodes document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the compute node for a key.  # noqa: E501

        Retrieve the document from the \"compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_compute_nodes_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the compute_nodes document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_nodes_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_nodes/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_edges_name(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge collection name")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> GetEdgesNameResponse:
        """Retrieve all edges from the designated collection.  # noqa: E501

        Retrieve all edges from the designated collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_edges_name(workflow, name, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge collection name (required)
        :type name: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetEdgesNameResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_edges_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_edges_name_with_http_info.raw_function(
            workflow,
            name,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def get_edges_name_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge collection name")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all edges from the designated collection.  # noqa: E501

        Retrieve all edges from the designated collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_edges_name_with_http_info(workflow, name, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge collection name (required)
        :type name: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetEdgesNameResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'name',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_edges_name" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEdgesNameResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/edges/{name}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_edges_name_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge collection name")],
        key: Annotated[StrictStr, Field(description="Edge key")],
        **kwargs,
    ) -> EdgesNameModel:
        """Retrieve an edge  # noqa: E501

        Retrieves an edge from the designated collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_edges_name_key(workflow, name, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge collection name (required)
        :type name: str
        :param key: Edge key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EdgesNameModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_edges_name_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_edges_name_key_with_http_info.raw_function(
            workflow,
            name,
            key,
            **kwargs,
        )

    @validate_call
    def get_edges_name_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge collection name")],
        key: Annotated[StrictStr, Field(description="Edge key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve an edge  # noqa: E501

        Retrieves an edge from the designated collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_edges_name_key_with_http_info(workflow, name, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge collection name (required)
        :type name: str
        :param key: Edge key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EdgesNameModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'name',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_edges_name_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['name'] is not None:
            _path_params['name'] = _params['name']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EdgesNameModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/edges/{name}/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_events(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        category: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetEventsResponse:
        """Retrieve all event documents  # noqa: E501

        Retrieve all documents from the \"events\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_events(workflow, skip, limit, sort_by, reverse_sort, key, category, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param category:
        :type category: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetEventsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_events_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_events_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            category,
            **kwargs,
        )

    @validate_call
    def get_events_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        category: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all event documents  # noqa: E501

        Retrieve all documents from the \"events\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_events_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, category, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param category:
        :type category: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetEventsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'category'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('category') is not None:  # noqa: E501
            _query_params.append(('category', _params['category']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEventsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/events', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_events_after_timestamp(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        timestamp: Annotated[Union[StrictFloat, StrictInt], Field(description="Timestamp expressed as number of milliseconds since the epoch in UTC")],
        category: Optional[StrictStr] = None,
        skip: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Ignored")] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> GetEventsResponse:
        """Return all events newer than the event with event_key.  # noqa: E501

        Return all events newer than the event with event_key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_events_after_timestamp(key, timestamp, category, skip, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param timestamp: Timestamp expressed as number of milliseconds since the epoch in UTC (required)
        :type timestamp: float
        :param category:
        :type category: str
        :param skip: Ignored
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetEventsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_events_after_timestamp_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_events_after_timestamp_with_http_info.raw_function(
            key,
            timestamp,
            category,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def get_events_after_timestamp_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        timestamp: Annotated[Union[StrictFloat, StrictInt], Field(description="Timestamp expressed as number of milliseconds since the epoch in UTC")],
        category: Optional[StrictStr] = None,
        skip: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Ignored")] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Return all events newer than the event with event_key.  # noqa: E501

        Return all events newer than the event with event_key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_events_after_timestamp_with_http_info(key, timestamp, category, skip, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param timestamp: Timestamp expressed as number of milliseconds since the epoch in UTC (required)
        :type timestamp: float
        :param category:
        :type category: str
        :param skip: Ignored
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetEventsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'timestamp',
            'category',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events_after_timestamp" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']

        if _params['timestamp'] is not None:
            _path_params['timestamp'] = _params['timestamp']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('category') is not None:  # noqa: E501
            _query_params.append(('category', _params['category']))

        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEventsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/events_after_timestamp/{timestamp}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_events_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the events document")],
        **kwargs,
    ) -> object:
        """Retrieve the event for a key.  # noqa: E501

        Retrieve the document from the \"events\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_events_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the events document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_events_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_events_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_events_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the events document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the event for a key.  # noqa: E501

        Retrieve the document from the \"events\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_events_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the events document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/events/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_files(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        path: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetFilesResponse:
        """Retrieve all file documents  # noqa: E501

        Retrieve all documents from the \"files\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_files(workflow, skip, limit, sort_by, reverse_sort, key, name, path, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetFilesResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_files_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            name,
            path,
            **kwargs,
        )

    @validate_call
    def get_files_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        path: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all file documents  # noqa: E501

        Retrieve all documents from the \"files\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_files_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, name, path, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetFilesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'name',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFilesResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/files', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_files_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the files document")],
        **kwargs,
    ) -> FilesModel:
        """Retrieve the file for a key.  # noqa: E501

        Retrieve the document from the \"files\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_files_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the files document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FilesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_files_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_files_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_files_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the files document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the file for a key.  # noqa: E501

        Retrieve the document from the \"files\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_files_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the files document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FilesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/files/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_files_produced_by_job_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> GetFilesProducedByJobKeyResponse:
        """Retrieve files produced by a job  # noqa: E501

        Retrieves files from the \"files\" collection produced by a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_files_produced_by_job_key(workflow, key, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetFilesProducedByJobKeyResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_files_produced_by_job_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_files_produced_by_job_key_with_http_info.raw_function(
            workflow,
            key,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def get_files_produced_by_job_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve files produced by a job  # noqa: E501

        Retrieves files from the \"files\" collection produced by a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_files_produced_by_job_key_with_http_info(workflow, key, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetFilesProducedByJobKeyResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_produced_by_job_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFilesProducedByJobKeyResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/files/produced_by_job/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_job_keys(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> object:
        """Retrieve all job keys for a workflow.  # noqa: E501

        Retrieves all job keys from the \"jobs\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_keys(workflow, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_job_keys_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_job_keys_with_http_info.raw_function(
            workflow,
            **kwargs,
        )

    @validate_call
    def get_job_keys_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all job keys for a workflow.  # noqa: E501

        Retrieves all job keys from the \"jobs\" collection for a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_keys_with_http_info(workflow, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_keys" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_keys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_job_process_stats(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        job_key: Optional[StrictStr] = None,
        run_id: Optional[StrictInt] = None,
        **kwargs,
    ) -> GetJobProcessStatsResponse:
        """Retrieve all job process statistics documents  # noqa: E501

        Retrieve all documents from the \"job_process_stats\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_process_stats(workflow, skip, limit, sort_by, reverse_sort, key, job_key, run_id, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param job_key:
        :type job_key: str
        :param run_id:
        :type run_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetJobProcessStatsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_job_process_stats_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_job_process_stats_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            job_key,
            run_id,
            **kwargs,
        )

    @validate_call
    def get_job_process_stats_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        job_key: Optional[StrictStr] = None,
        run_id: Optional[StrictInt] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all job process statistics documents  # noqa: E501

        Retrieve all documents from the \"job_process_stats\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_process_stats_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, job_key, run_id, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param job_key:
        :type job_key: str
        :param run_id:
        :type run_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetJobProcessStatsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'job_key',
            'run_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_process_stats" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('job_key') is not None:  # noqa: E501
            _query_params.append(('job_key', _params['job_key']))

        if _params.get('run_id') is not None:  # noqa: E501
            _query_params.append(('run_id', _params['run_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetJobProcessStatsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_process_stats', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_job_process_stats_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the job_process_stats document")],
        **kwargs,
    ) -> JobProcessStatsModel:
        """Retrieve the job process statistics for a key.  # noqa: E501

        Retrieve the document from the \"job_process_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_process_stats_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the job_process_stats document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobProcessStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_job_process_stats_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_job_process_stats_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_job_process_stats_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the job_process_stats document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the job process statistics for a key.  # noqa: E501

        Retrieve the document from the \"job_process_stats\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_process_stats_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the job_process_stats document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobProcessStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_process_stats_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobProcessStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_process_stats/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_job_specifications(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> GetJobSpecificationsResponse:
        """Retrieve all job definitions  # noqa: E501

        Retrieves all job definitions. Limit output with skip and limit.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_specifications(workflow, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetJobSpecificationsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_job_specifications_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_job_specifications_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def get_job_specifications_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all job definitions  # noqa: E501

        Retrieves all job definitions. Limit output with skip and limit.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_specifications_with_http_info(workflow, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetJobSpecificationsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_specifications" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetJobSpecificationsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_specifications', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_job_specifications_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> JobSpecificationsModel:
        """Retrieve a job  # noqa: E501

        Retrieves a job from the \"jobs\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_specifications_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobSpecificationsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_job_specifications_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_job_specifications_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_job_specifications_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve a job  # noqa: E501

        Retrieves a job from the \"jobs\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_specifications_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobSpecificationsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_specifications_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobSpecificationsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_specifications/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        command: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        cancel_on_blocking_job_failure: Optional[StrictBool] = None,
        supports_termination: Optional[StrictBool] = None,
        **kwargs,
    ) -> GetJobsResponse:
        """Retrieve all job documents  # noqa: E501

        Retrieve all documents from the \"jobs\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs(workflow, skip, limit, sort_by, reverse_sort, key, name, command, status, cancel_on_blocking_job_failure, supports_termination, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param command:
        :type command: str
        :param status:
        :type status: str
        :param cancel_on_blocking_job_failure:
        :type cancel_on_blocking_job_failure: bool
        :param supports_termination:
        :type supports_termination: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetJobsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            name,
            command,
            status,
            cancel_on_blocking_job_failure,
            supports_termination,
            **kwargs,
        )

    @validate_call
    def get_jobs_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        command: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        cancel_on_blocking_job_failure: Optional[StrictBool] = None,
        supports_termination: Optional[StrictBool] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all job documents  # noqa: E501

        Retrieve all documents from the \"jobs\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, name, command, status, cancel_on_blocking_job_failure, supports_termination, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param command:
        :type command: str
        :param status:
        :type status: str
        :param cancel_on_blocking_job_failure:
        :type cancel_on_blocking_job_failure: bool
        :param supports_termination:
        :type supports_termination: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetJobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'name',
            'command',
            'status',
            'cancel_on_blocking_job_failure',
            'supports_termination'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('command') is not None:  # noqa: E501
            _query_params.append(('command', _params['command']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('cancel_on_blocking_job_failure') is not None:  # noqa: E501
            _query_params.append(('cancel_on_blocking_job_failure', _params['cancel_on_blocking_job_failure']))

        if _params.get('supports_termination') is not None:  # noqa: E501
            _query_params.append(('supports_termination', _params['supports_termination']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetJobsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs_find_by_needs_file_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="File key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> GetJobsFindByNeedsFileKeyResponse:
        """Retrieve all jobs that need a file  # noqa: E501

        Retrieves all jobs connected to a file by the needs edge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_find_by_needs_file_key(workflow, key, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: File key (required)
        :type key: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetJobsFindByNeedsFileKeyResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_find_by_needs_file_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_find_by_needs_file_key_with_http_info.raw_function(
            workflow,
            key,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def get_jobs_find_by_needs_file_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="File key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all jobs that need a file  # noqa: E501

        Retrieves all jobs connected to a file by the needs edge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_find_by_needs_file_key_with_http_info(workflow, key, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: File key (required)
        :type key: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetJobsFindByNeedsFileKeyResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_find_by_needs_file_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetJobsFindByNeedsFileKeyResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/find_by_needs_file/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs_find_by_status_status(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        status: Annotated[StrictStr, Field(description="Job status.")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> GetJobsFindByStatusStatusResponse:
        """Retrieve all jobs with a specific status  # noqa: E501

        Retrieves all jobs from the \"jobs\" collection with a specific status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_find_by_status_status(workflow, status, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param status: Job status. (required)
        :type status: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetJobsFindByStatusStatusResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_find_by_status_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_find_by_status_status_with_http_info.raw_function(
            workflow,
            status,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def get_jobs_find_by_status_status_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        status: Annotated[StrictStr, Field(description="Job status.")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all jobs with a specific status  # noqa: E501

        Retrieves all jobs from the \"jobs\" collection with a specific status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_find_by_status_status_with_http_info(workflow, status, skip, limit, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param status: Job status. (required)
        :type status: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetJobsFindByStatusStatusResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'status',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_find_by_status_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['status'] is not None:
            _path_params['status'] = _params['status']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetJobsFindByStatusStatusResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/find_by_status/{status}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the jobs document")],
        **kwargs,
    ) -> JobsModel:
        """Retrieve the job for a key.  # noqa: E501

        Retrieve the document from the \"jobs\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the jobs document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_jobs_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the jobs document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the job for a key.  # noqa: E501

        Retrieve the document from the \"jobs\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the jobs document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs_key_process_stats(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> List[JobProcessStatsModel]:
        """Retrieve the job process stats for a job.  # noqa: E501

        Retrieve the job process stats for a job by its key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_process_stats(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[JobProcessStatsModel]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_key_process_stats_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_key_process_stats_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_jobs_key_process_stats_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the job process stats for a job.  # noqa: E501

        Retrieve the job process stats for a job by its key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_process_stats_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[JobProcessStatsModel], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_key_process_stats" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[JobProcessStatsModel]",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/process_stats', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs_key_resource_requirements(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ResourceRequirementsModel:
        """Retrieve the resource requirements for a job.  # noqa: E501

        Retrieve the resource requirements for a job by its key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_resource_requirements(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResourceRequirementsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_key_resource_requirements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_key_resource_requirements_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_jobs_key_resource_requirements_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the resource requirements for a job.  # noqa: E501

        Retrieve the resource requirements for a job by its key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_resource_requirements_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResourceRequirementsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_key_resource_requirements" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRequirementsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/resource_requirements', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs_key_user_data_consumes(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> GetJobsKeyUserDataConsumesResponse:
        """Retrieve all user data consumed by a job.  # noqa: E501

        Retrieve all user data consumed by a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_user_data_consumes(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetJobsKeyUserDataConsumesResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_key_user_data_consumes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_key_user_data_consumes_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_jobs_key_user_data_consumes_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all user data consumed by a job.  # noqa: E501

        Retrieve all user data consumed by a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_user_data_consumes_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetJobsKeyUserDataConsumesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_key_user_data_consumes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetJobsKeyUserDataConsumesResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/user_data_consumes', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_jobs_key_user_data_stores(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> GetJobsKeyUserDataStoresResponse:
        """Retrieve all user data for a job.  # noqa: E501

        Retrieve all user data for a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_user_data_stores(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetJobsKeyUserDataStoresResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_jobs_key_user_data_stores_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_jobs_key_user_data_stores_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_jobs_key_user_data_stores_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all user data for a job.  # noqa: E501

        Retrieve all user data for a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_key_user_data_stores_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetJobsKeyUserDataStoresResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_key_user_data_stores" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetJobsKeyUserDataStoresResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/user_data_stores', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_latest_event_timestamp(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> object:
        """Return the timestamp of the latest event.  # noqa: E501

        Return the timestamp of the latest event in ms since the epoch in UTC.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_latest_event_timestamp(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_latest_event_timestamp_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_latest_event_timestamp_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_latest_event_timestamp_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """Return the timestamp of the latest event.  # noqa: E501

        Return the timestamp of the latest event in ms since the epoch in UTC.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_latest_event_timestamp_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_latest_event_timestamp" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/latest_event_timestamp', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_local_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        memory: Optional[StrictStr] = None,
        num_cpus: Optional[StrictInt] = None,
        **kwargs,
    ) -> GetLocalSchedulersResponse:
        """Retrieve all local compute node configuration documents  # noqa: E501

        Retrieve all documents from the \"local_schedulers\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_local_schedulers(workflow, skip, limit, sort_by, reverse_sort, key, memory, num_cpus, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param memory:
        :type memory: str
        :param num_cpus:
        :type num_cpus: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetLocalSchedulersResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_local_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_local_schedulers_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            memory,
            num_cpus,
            **kwargs,
        )

    @validate_call
    def get_local_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        memory: Optional[StrictStr] = None,
        num_cpus: Optional[StrictInt] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all local compute node configuration documents  # noqa: E501

        Retrieve all documents from the \"local_schedulers\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_local_schedulers_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, memory, num_cpus, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param memory:
        :type memory: str
        :param num_cpus:
        :type num_cpus: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetLocalSchedulersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'memory',
            'num_cpus'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_local_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('memory') is not None:  # noqa: E501
            _query_params.append(('memory', _params['memory']))

        if _params.get('num_cpus') is not None:  # noqa: E501
            _query_params.append(('num_cpus', _params['num_cpus']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetLocalSchedulersResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/local_schedulers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_local_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the local_schedulers document")],
        **kwargs,
    ) -> LocalSchedulersModel:
        """Retrieve the local compute node configuration for a key.  # noqa: E501

        Retrieve the document from the \"local_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_local_schedulers_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the local_schedulers document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LocalSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_local_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_local_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_local_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the local_schedulers document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the local compute node configuration for a key.  # noqa: E501

        Retrieve the document from the \"local_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_local_schedulers_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the local_schedulers document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LocalSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_local_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/local_schedulers/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_ping(
        self,
        **kwargs,
    ) -> object:
        """Check if the service is running.  # noqa: E501

        Check if the service is running.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_ping(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_ping_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_ping_with_http_info.raw_function(
            **kwargs,
        )

    @validate_call
    def get_ping_with_http_info(
        self,
        **kwargs,
    ) -> ApiResponse:
        """Check if the service is running.  # noqa: E501

        Check if the service is running.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_ping_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ping" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}

        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/ping', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_resource_requirements(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        memory: Optional[StrictStr] = None,
        num_cpus: Optional[StrictInt] = None,
        num_gpus: Optional[StrictInt] = None,
        num_nodes: Optional[StrictInt] = None,
        runtime: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetResourceRequirementsResponse:
        """Retrieve all resource requirements documents  # noqa: E501

        Retrieve all documents from the \"resource_requirements\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_resource_requirements(workflow, skip, limit, sort_by, reverse_sort, key, name, memory, num_cpus, num_gpus, num_nodes, runtime, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param memory:
        :type memory: str
        :param num_cpus:
        :type num_cpus: int
        :param num_gpus:
        :type num_gpus: int
        :param num_nodes:
        :type num_nodes: int
        :param runtime:
        :type runtime: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetResourceRequirementsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_resource_requirements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_resource_requirements_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            name,
            memory,
            num_cpus,
            num_gpus,
            num_nodes,
            runtime,
            **kwargs,
        )

    @validate_call
    def get_resource_requirements_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        memory: Optional[StrictStr] = None,
        num_cpus: Optional[StrictInt] = None,
        num_gpus: Optional[StrictInt] = None,
        num_nodes: Optional[StrictInt] = None,
        runtime: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all resource requirements documents  # noqa: E501

        Retrieve all documents from the \"resource_requirements\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_resource_requirements_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, name, memory, num_cpus, num_gpus, num_nodes, runtime, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param memory:
        :type memory: str
        :param num_cpus:
        :type num_cpus: int
        :param num_gpus:
        :type num_gpus: int
        :param num_nodes:
        :type num_nodes: int
        :param runtime:
        :type runtime: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetResourceRequirementsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'name',
            'memory',
            'num_cpus',
            'num_gpus',
            'num_nodes',
            'runtime'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_requirements" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('memory') is not None:  # noqa: E501
            _query_params.append(('memory', _params['memory']))

        if _params.get('num_cpus') is not None:  # noqa: E501
            _query_params.append(('num_cpus', _params['num_cpus']))

        if _params.get('num_gpus') is not None:  # noqa: E501
            _query_params.append(('num_gpus', _params['num_gpus']))

        if _params.get('num_nodes') is not None:  # noqa: E501
            _query_params.append(('num_nodes', _params['num_nodes']))

        if _params.get('runtime') is not None:  # noqa: E501
            _query_params.append(('runtime', _params['runtime']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetResourceRequirementsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/resource_requirements', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_resource_requirements_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the resource_requirements document")],
        **kwargs,
    ) -> ResourceRequirementsModel:
        """Retrieve the resource requirements for a key.  # noqa: E501

        Retrieve the document from the \"resource_requirements\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_resource_requirements_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the resource_requirements document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResourceRequirementsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_resource_requirements_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_resource_requirements_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_resource_requirements_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the resource_requirements document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the resource requirements for a key.  # noqa: E501

        Retrieve the document from the \"resource_requirements\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_resource_requirements_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the resource_requirements document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResourceRequirementsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_requirements_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRequirementsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/resource_requirements/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_results(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        job_key: Optional[StrictStr] = None,
        run_id: Optional[StrictInt] = None,
        return_code: Optional[StrictInt] = None,
        status: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetResultsResponse:
        """Retrieve all result documents  # noqa: E501

        Retrieve all documents from the \"results\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_results(workflow, skip, limit, sort_by, reverse_sort, key, job_key, run_id, return_code, status, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param job_key:
        :type job_key: str
        :param run_id:
        :type run_id: int
        :param return_code:
        :type return_code: int
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetResultsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_results_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_results_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            job_key,
            run_id,
            return_code,
            status,
            **kwargs,
        )

    @validate_call
    def get_results_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        job_key: Optional[StrictStr] = None,
        run_id: Optional[StrictInt] = None,
        return_code: Optional[StrictInt] = None,
        status: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all result documents  # noqa: E501

        Retrieve all documents from the \"results\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_results_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, job_key, run_id, return_code, status, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param job_key:
        :type job_key: str
        :param run_id:
        :type run_id: int
        :param return_code:
        :type return_code: int
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetResultsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'job_key',
            'run_id',
            'return_code',
            'status'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_results" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('job_key') is not None:  # noqa: E501
            _query_params.append(('job_key', _params['job_key']))

        if _params.get('run_id') is not None:  # noqa: E501
            _query_params.append(('run_id', _params['run_id']))

        if _params.get('return_code') is not None:  # noqa: E501
            _query_params.append(('return_code', _params['return_code']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetResultsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/results', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_results_find_by_job_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ResultsModel:
        """Retrieve the latest result for a job  # noqa: E501

        Retrieve the latest result for a job. Throws an error if no result is stored.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_results_find_by_job_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResultsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_results_find_by_job_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_results_find_by_job_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_results_find_by_job_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the latest result for a job  # noqa: E501

        Retrieve the latest result for a job. Throws an error if no result is stored.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_results_find_by_job_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResultsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_results_find_by_job_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/results/find_by_job/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_results_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the results document")],
        **kwargs,
    ) -> ResultsModel:
        """Retrieve the result for a key.  # noqa: E501

        Retrieve the document from the \"results\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_results_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the results document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResultsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_results_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_results_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_results_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the results document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the result for a key.  # noqa: E501

        Retrieve the document from the \"results\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_results_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the results document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResultsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_results_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/results/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_scheduled_compute_nodes(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        scheduler_id: Optional[StrictStr] = None,
        scheduler_config_id: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetScheduledComputeNodesResponse:
        """Retrieve all scheduled compute node documents  # noqa: E501

        Retrieve all documents from the \"scheduled_compute_nodes\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_compute_nodes(workflow, skip, limit, sort_by, reverse_sort, key, scheduler_id, scheduler_config_id, status, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param scheduler_id:
        :type scheduler_id: str
        :param scheduler_config_id:
        :type scheduler_config_id: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetScheduledComputeNodesResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_scheduled_compute_nodes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_scheduled_compute_nodes_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            scheduler_id,
            scheduler_config_id,
            status,
            **kwargs,
        )

    @validate_call
    def get_scheduled_compute_nodes_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        scheduler_id: Optional[StrictStr] = None,
        scheduler_config_id: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all scheduled compute node documents  # noqa: E501

        Retrieve all documents from the \"scheduled_compute_nodes\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_compute_nodes_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, scheduler_id, scheduler_config_id, status, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param scheduler_id:
        :type scheduler_id: str
        :param scheduler_config_id:
        :type scheduler_config_id: str
        :param status:
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetScheduledComputeNodesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'scheduler_id',
            'scheduler_config_id',
            'status'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scheduled_compute_nodes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('scheduler_id') is not None:  # noqa: E501
            _query_params.append(('scheduler_id', _params['scheduler_id']))

        if _params.get('scheduler_config_id') is not None:  # noqa: E501
            _query_params.append(('scheduler_config_id', _params['scheduler_config_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetScheduledComputeNodesResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/scheduled_compute_nodes', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_scheduled_compute_nodes_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the scheduled_compute_nodes document")],
        **kwargs,
    ) -> ScheduledComputeNodesModel:
        """Retrieve the scheduled compute node for a key.  # noqa: E501

        Retrieve the document from the \"scheduled_compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_compute_nodes_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the scheduled_compute_nodes document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ScheduledComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_scheduled_compute_nodes_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_scheduled_compute_nodes_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_scheduled_compute_nodes_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the scheduled_compute_nodes document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the scheduled compute node for a key.  # noqa: E501

        Retrieve the document from the \"scheduled_compute_nodes\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_compute_nodes_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the scheduled_compute_nodes document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ScheduledComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scheduled_compute_nodes_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/scheduled_compute_nodes/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_slurm_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        account: Optional[StrictStr] = None,
        gres: Optional[StrictStr] = None,
        mem: Optional[StrictStr] = None,
        nodes: Optional[StrictInt] = None,
        partition: Optional[StrictStr] = None,
        qos: Optional[StrictStr] = None,
        tmp: Optional[StrictStr] = None,
        walltime: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetSlurmSchedulersResponse:
        """Retrieve all Slurm compute node configuration documents  # noqa: E501

        Retrieve all documents from the \"slurm_schedulers\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_slurm_schedulers(workflow, skip, limit, sort_by, reverse_sort, key, name, account, gres, mem, nodes, partition, qos, tmp, walltime, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param account:
        :type account: str
        :param gres:
        :type gres: str
        :param mem:
        :type mem: str
        :param nodes:
        :type nodes: int
        :param partition:
        :type partition: str
        :param qos:
        :type qos: str
        :param tmp:
        :type tmp: str
        :param walltime:
        :type walltime: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetSlurmSchedulersResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_slurm_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_slurm_schedulers_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            name,
            account,
            gres,
            mem,
            nodes,
            partition,
            qos,
            tmp,
            walltime,
            **kwargs,
        )

    @validate_call
    def get_slurm_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        account: Optional[StrictStr] = None,
        gres: Optional[StrictStr] = None,
        mem: Optional[StrictStr] = None,
        nodes: Optional[StrictInt] = None,
        partition: Optional[StrictStr] = None,
        qos: Optional[StrictStr] = None,
        tmp: Optional[StrictStr] = None,
        walltime: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all Slurm compute node configuration documents  # noqa: E501

        Retrieve all documents from the \"slurm_schedulers\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_slurm_schedulers_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, name, account, gres, mem, nodes, partition, qos, tmp, walltime, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param account:
        :type account: str
        :param gres:
        :type gres: str
        :param mem:
        :type mem: str
        :param nodes:
        :type nodes: int
        :param partition:
        :type partition: str
        :param qos:
        :type qos: str
        :param tmp:
        :type tmp: str
        :param walltime:
        :type walltime: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetSlurmSchedulersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'name',
            'account',
            'gres',
            'mem',
            'nodes',
            'partition',
            'qos',
            'tmp',
            'walltime'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_slurm_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('account') is not None:  # noqa: E501
            _query_params.append(('account', _params['account']))

        if _params.get('gres') is not None:  # noqa: E501
            _query_params.append(('gres', _params['gres']))

        if _params.get('mem') is not None:  # noqa: E501
            _query_params.append(('mem', _params['mem']))

        if _params.get('nodes') is not None:  # noqa: E501
            _query_params.append(('nodes', _params['nodes']))

        if _params.get('partition') is not None:  # noqa: E501
            _query_params.append(('partition', _params['partition']))

        if _params.get('qos') is not None:  # noqa: E501
            _query_params.append(('qos', _params['qos']))

        if _params.get('tmp') is not None:  # noqa: E501
            _query_params.append(('tmp', _params['tmp']))

        if _params.get('walltime') is not None:  # noqa: E501
            _query_params.append(('walltime', _params['walltime']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetSlurmSchedulersResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/slurm_schedulers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_slurm_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the slurm_schedulers document")],
        **kwargs,
    ) -> SlurmSchedulersModel:
        """Retrieve the Slurm compute node configuration for a key.  # noqa: E501

        Retrieve the document from the \"slurm_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_slurm_schedulers_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the slurm_schedulers document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SlurmSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_slurm_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_slurm_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_slurm_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the slurm_schedulers document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the Slurm compute node configuration for a key.  # noqa: E501

        Retrieve the document from the \"slurm_schedulers\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_slurm_schedulers_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the slurm_schedulers document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SlurmSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_slurm_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SlurmSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/slurm_schedulers/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_user_data(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        is_ephemeral: Optional[StrictBool] = None,
        **kwargs,
    ) -> GetUserDataResponse:
        """Retrieve all user data documents  # noqa: E501

        Retrieve all documents from the \"user_data\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_data(workflow, skip, limit, sort_by, reverse_sort, key, name, is_ephemeral, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param is_ephemeral:
        :type is_ephemeral: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetUserDataResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_user_data_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_user_data_with_http_info.raw_function(
            workflow,
            skip,
            limit,
            sort_by,
            reverse_sort,
            key,
            name,
            is_ephemeral,
            **kwargs,
        )

    @validate_call
    def get_user_data_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        key: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        is_ephemeral: Optional[StrictBool] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all user data documents  # noqa: E501

        Retrieve all documents from the \"user_data\" collection for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_data_with_http_info(workflow, skip, limit, sort_by, reverse_sort, key, name, is_ephemeral, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param key:
        :type key: str
        :param name:
        :type name: str
        :param is_ephemeral:
        :type is_ephemeral: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetUserDataResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'skip',
            'limit',
            'sort_by',
            'reverse_sort',
            'key',
            'name',
            'is_ephemeral'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_data" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('key') is not None:  # noqa: E501
            _query_params.append(('_key', _params['key']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('is_ephemeral') is not None:  # noqa: E501
            _query_params.append(('is_ephemeral', _params['is_ephemeral']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetUserDataResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/user_data', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_user_data_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the user_data document")],
        **kwargs,
    ) -> UserDataModel:
        """Retrieve the user data for a key.  # noqa: E501

        Retrieve the document from the \"user_data\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_data_key(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the user_data document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDataModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_user_data_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_user_data_key_with_http_info.raw_function(
            workflow,
            key,
            **kwargs,
        )

    @validate_call
    def get_user_data_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="key of the user_data document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the user data for a key.  # noqa: E501

        Retrieve the document from the \"user_data\" collection by key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_data_key_with_http_info(workflow, key, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: key of the user_data document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDataModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_data_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDataModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/user_data/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_version(
        self,
        **kwargs,
    ) -> object:
        """Return the version of the service.  # noqa: E501

        Return the version of the service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_version(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_version_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_version_with_http_info.raw_function(
            **kwargs,
        )

    @validate_call
    def get_version_with_http_info(
        self,
        **kwargs,
    ) -> ApiResponse:
        """Return the version of the service.  # noqa: E501

        Return the version of the service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_version_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}

        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/version', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflow_specifications_example(
        self,
        **kwargs,
    ) -> WorkflowSpecificationsModel:
        """Retrieve an example workflow specification  # noqa: E501

        Retrieves an example workflow specification in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_specifications_example(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowSpecificationsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflow_specifications_example_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflow_specifications_example_with_http_info.raw_function(
            **kwargs,
        )

    @validate_call
    def get_workflow_specifications_example_with_http_info(
        self,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve an example workflow specification  # noqa: E501

        Retrieves an example workflow specification in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_specifications_example_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowSpecificationsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_specifications_example" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}

        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowSpecificationsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflow_specifications/example', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflow_specifications_key(
        self,
        key: Annotated[StrictStr, Field(description="key of the workflow.")],
        **kwargs,
    ) -> WorkflowSpecificationsModel:
        """Retrieve the current workflow  # noqa: E501

        Retrieves the current workflow in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_specifications_key(key, async_req=True)
        >>> result = thread.get()

        :param key: key of the workflow. (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowSpecificationsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflow_specifications_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflow_specifications_key_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflow_specifications_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="key of the workflow.")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the current workflow  # noqa: E501

        Retrieves the current workflow in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_specifications_key_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: key of the workflow. (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowSpecificationsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_specifications_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowSpecificationsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflow_specifications/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflow_specifications_template(
        self,
        **kwargs,
    ) -> WorkflowSpecificationsModel:
        """Retrieve the workflow specification template  # noqa: E501

        Retrieve the workflow specification template in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_specifications_template(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowSpecificationsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflow_specifications_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflow_specifications_template_with_http_info.raw_function(
            **kwargs,
        )

    @validate_call
    def get_workflow_specifications_template_with_http_info(
        self,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the workflow specification template  # noqa: E501

        Retrieve the workflow specification template in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_specifications_template_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowSpecificationsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_specifications_template" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}

        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowSpecificationsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflow_specifications/template', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows(
        self,
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        name: Optional[StrictStr] = None,
        user: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        **kwargs,
    ) -> GetWorkflowsResponse:
        """Retrieve all workflows  # noqa: E501

        Retrieves all documents from the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows(skip, sort_by, reverse_sort, limit, name, user, description, async_req=True)
        >>> result = thread.get()

        :param skip:
        :type skip: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param limit:
        :type limit: float
        :param name:
        :type name: str
        :param user:
        :type user: str
        :param description:
        :type description: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_with_http_info.raw_function(
            skip,
            sort_by,
            reverse_sort,
            limit,
            name,
            user,
            description,
            **kwargs,
        )

    @validate_call
    def get_workflows_with_http_info(
        self,
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        sort_by: Optional[StrictStr] = None,
        reverse_sort: Optional[StrictBool] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        name: Optional[StrictStr] = None,
        user: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all workflows  # noqa: E501

        Retrieves all documents from the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_with_http_info(skip, sort_by, reverse_sort, limit, name, user, description, async_req=True)
        >>> result = thread.get()

        :param skip:
        :type skip: float
        :param sort_by:
        :type sort_by: str
        :param reverse_sort:
        :type reverse_sort: bool
        :param limit:
        :type limit: float
        :param name:
        :type name: str
        :param user:
        :type user: str
        :param description:
        :type description: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'skip',
            'sort_by',
            'reverse_sort',
            'limit',
            'name',
            'user',
            'description'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}

        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('sort_by') is not None:  # noqa: E501
            _query_params.append(('sort_by', _params['sort_by']))

        if _params.get('reverse_sort') is not None:  # noqa: E501
            _query_params.append(('reverse_sort', _params['reverse_sort']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('user') is not None:  # noqa: E501
            _query_params.append(('user', _params['user']))

        if _params.get('description') is not None:  # noqa: E501
            _query_params.append(('description', _params['description']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWorkflowsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key(
        self,
        key: Annotated[StrictStr, Field(description="key of the workflows document")],
        **kwargs,
    ) -> WorkflowsModel:
        """Retrieve the workflow for an key.  # noqa: E501

        Retrieve the document for a key from the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key(key, async_req=True)
        >>> result = thread.get()

        :param key: key of the workflows document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="key of the workflows document")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve the workflow for an key.  # noqa: E501

        Retrieve the document for a key from the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: key of the workflows document (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_collection_names(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> GetWorkflowsKeyCollectionNamesResponse:
        """Retrieve all collection names for one workflow.  # noqa: E501

        Retrieve all collection names for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_collection_names(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsKeyCollectionNamesResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_collection_names_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_collection_names_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_collection_names_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve all collection names for one workflow.  # noqa: E501

        Retrieve all collection names for one workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_collection_names_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsKeyCollectionNamesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_collection_names" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWorkflowsKeyCollectionNamesResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/collection_names', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_config(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> WorkflowConfigModel:
        """Returns the workflow config.  # noqa: E501

        Returns the workflow config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_config(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowConfigModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_config_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_config_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """Returns the workflow config.  # noqa: E501

        Returns the workflow config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_config_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowConfigModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowConfigModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/config', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_dot_graph_name(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Graph name")],
        **kwargs,
    ) -> GetWorkflowsKeyDotGraphNameResponse:
        """Build a string for a DOT graph.  # noqa: E501

        Build a string for a DOT graph.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_dot_graph_name(key, name, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param name: Graph name (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsKeyDotGraphNameResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_dot_graph_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_dot_graph_name_with_http_info.raw_function(
            key,
            name,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_dot_graph_name_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Graph name")],
        **kwargs,
    ) -> ApiResponse:
        """Build a string for a DOT graph.  # noqa: E501

        Build a string for a DOT graph.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_dot_graph_name_with_http_info(key, name, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param name: Graph name (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsKeyDotGraphNameResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_dot_graph_name" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']

        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWorkflowsKeyDotGraphNameResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/dot_graph/{name}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_is_complete(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> GetWorkflowsKeyIsCompleteResponse:
        """Report whether the workflow is complete  # noqa: E501

        Reports true if all jobs in the workflow are complete.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_is_complete(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsKeyIsCompleteResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_is_complete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_is_complete_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_is_complete_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """Report whether the workflow is complete  # noqa: E501

        Reports true if all jobs in the workflow are complete.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_is_complete_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsKeyIsCompleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_is_complete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWorkflowsKeyIsCompleteResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/is_complete', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_missing_user_data(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> GetWorkflowsKeyMissingUserDataResponse:
        """List missing user data that should exist.  # noqa: E501

        List missing user data that should exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_missing_user_data(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsKeyMissingUserDataResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_missing_user_data_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_missing_user_data_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_missing_user_data_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """List missing user data that should exist.  # noqa: E501

        List missing user data that should exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_missing_user_data_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsKeyMissingUserDataResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_missing_user_data" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWorkflowsKeyMissingUserDataResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/missing_user_data', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_ready_job_requirements(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        scheduler_config_id: Annotated[Optional[StrictStr], Field(description="Limit output to jobs assigned this scheduler.")] = None,
        **kwargs,
    ) -> GetWorkflowsKeyReadyJobRequirementsResponse:
        """Return the resource requirements for ready jobs.  # noqa: E501

        Return the resource requirements for jobs with a status of ready.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_ready_job_requirements(key, scheduler_config_id, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param scheduler_config_id: Limit output to jobs assigned this scheduler.
        :type scheduler_config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsKeyReadyJobRequirementsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_ready_job_requirements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_ready_job_requirements_with_http_info.raw_function(
            key,
            scheduler_config_id,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_ready_job_requirements_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        scheduler_config_id: Annotated[Optional[StrictStr], Field(description="Limit output to jobs assigned this scheduler.")] = None,
        **kwargs,
    ) -> ApiResponse:
        """Return the resource requirements for ready jobs.  # noqa: E501

        Return the resource requirements for jobs with a status of ready.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_ready_job_requirements_with_http_info(key, scheduler_config_id, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param scheduler_config_id: Limit output to jobs assigned this scheduler.
        :type scheduler_config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsKeyReadyJobRequirementsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'scheduler_config_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_ready_job_requirements" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('scheduler_config_id') is not None:  # noqa: E501
            _query_params.append(('scheduler_config_id', _params['scheduler_config_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWorkflowsKeyReadyJobRequirementsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/ready_job_requirements', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_required_existing_files(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> GetWorkflowsKeyRequiredExistingFilesResponse:
        """List files that must exist.  # noqa: E501

        List files that must exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_required_existing_files(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsKeyRequiredExistingFilesResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_required_existing_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_required_existing_files_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_required_existing_files_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """List files that must exist.  # noqa: E501

        List files that must exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_required_existing_files_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsKeyRequiredExistingFilesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_required_existing_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWorkflowsKeyRequiredExistingFilesResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/required_existing_files', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_workflows_key_status(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> WorkflowStatusModel:
        """Reports the workflow status.  # noqa: E501

        Reports the workflow status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_status(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowStatusModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_workflows_key_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_workflows_key_status_with_http_info.raw_function(
            key,
            **kwargs,
        )

    @validate_call
    def get_workflows_key_status_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        **kwargs,
    ) -> ApiResponse:
        """Reports the workflow status.  # noqa: E501

        Reports the workflow status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_key_status_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowStatusModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows_key_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowStatusModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_aws_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[AwsSchedulersModel, Field(description="AWS compute node configuration.")],
        **kwargs,
    ) -> AwsSchedulersModel:
        """Store a AWS compute node configuration.  # noqa: E501

        Store a AWS compute node configuration in the \"aws_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_aws_schedulers(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: AWS compute node configuration. (required)
        :type body: AwsSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AwsSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_aws_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_aws_schedulers_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_aws_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[AwsSchedulersModel, Field(description="AWS compute node configuration.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a AWS compute node configuration.  # noqa: E501

        Store a AWS compute node configuration in the \"aws_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_aws_schedulers_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: AWS compute node configuration. (required)
        :type body: AwsSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AwsSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_aws_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AwsSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/aws_schedulers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_bulk_jobs(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: BulkJobsModel,
        **kwargs,
    ) -> object:
        """Add jobs in bulk with edge definitions.  # noqa: E501

        Add jobs in bulk with edge definitions. Recommended max job count of 10,000.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_bulk_jobs(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: (required)
        :type body: BulkJobsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_bulk_jobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_bulk_jobs_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_bulk_jobs_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: BulkJobsModel,
        **kwargs,
    ) -> ApiResponse:
        """Add jobs in bulk with edge definitions.  # noqa: E501

        Add jobs in bulk with edge definitions. Recommended max job count of 10,000.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_bulk_jobs_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: (required)
        :type body: BulkJobsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_bulk_jobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/bulk_jobs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_compute_node_stats(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ComputeNodeStatsModel, Field(description="compute node statistics.")],
        **kwargs,
    ) -> ComputeNodeStatsModel:
        """Store a compute node statistics.  # noqa: E501

        Store a compute node statistics in the \"compute_node_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_compute_node_stats(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: compute node statistics. (required)
        :type body: ComputeNodeStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodeStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_compute_node_stats_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_compute_node_stats_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_compute_node_stats_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ComputeNodeStatsModel, Field(description="compute node statistics.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a compute node statistics.  # noqa: E501

        Store a compute node statistics in the \"compute_node_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_compute_node_stats_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: compute node statistics. (required)
        :type body: ComputeNodeStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodeStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_compute_node_stats" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodeStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_node_stats', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_compute_nodes(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ComputeNodesModel, Field(description="compute node.")],
        **kwargs,
    ) -> ComputeNodesModel:
        """Store a compute node.  # noqa: E501

        Store a compute node in the \"compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_compute_nodes(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: compute node. (required)
        :type body: ComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_compute_nodes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_compute_nodes_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_compute_nodes_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ComputeNodesModel, Field(description="compute node.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a compute node.  # noqa: E501

        Store a compute node in the \"compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_compute_nodes_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: compute node. (required)
        :type body: ComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_compute_nodes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_nodes', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_edges_name(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge name")],
        body: Annotated[EdgesNameModel, Field(description="Relationship between two vertexes")],
        **kwargs,
    ) -> EdgesNameModel:
        """Store an edge between two vertexes.  # noqa: E501

        Store an edge between two vertexes in the designated collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_edges_name(workflow, name, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge name (required)
        :type name: str
        :param body: Relationship between two vertexes (required)
        :type body: EdgesNameModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EdgesNameModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_edges_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_edges_name_with_http_info.raw_function(
            workflow,
            name,
            body,
            **kwargs,
        )

    @validate_call
    def post_edges_name_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        name: Annotated[StrictStr, Field(description="Edge name")],
        body: Annotated[EdgesNameModel, Field(description="Relationship between two vertexes")],
        **kwargs,
    ) -> ApiResponse:
        """Store an edge between two vertexes.  # noqa: E501

        Store an edge between two vertexes in the designated collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_edges_name_with_http_info(workflow, name, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param name: Edge name (required)
        :type name: str
        :param body: Relationship between two vertexes (required)
        :type body: EdgesNameModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EdgesNameModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'name',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_edges_name" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EdgesNameModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/edges/{name}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_events(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[Dict[str, Any], Field(description="event.")],
        **kwargs,
    ) -> object:
        """Store a event.  # noqa: E501

        Store a event in the \"events\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_events(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: event. (required)
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_events_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_events_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_events_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[Dict[str, Any], Field(description="event.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a event.  # noqa: E501

        Store a event in the \"events\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_events_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: event. (required)
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_events" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/events', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_files(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[FilesModel, Field(description="file.")],
        **kwargs,
    ) -> FilesModel:
        """Store a file.  # noqa: E501

        Store a file in the \"files\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_files(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: file. (required)
        :type body: FilesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FilesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_files_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_files_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[FilesModel, Field(description="file.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a file.  # noqa: E501

        Store a file in the \"files\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_files_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: file. (required)
        :type body: FilesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FilesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/files', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_job_process_stats(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[JobProcessStatsModel, Field(description="job process statistics.")],
        **kwargs,
    ) -> JobProcessStatsModel:
        """Store a job process statistics.  # noqa: E501

        Store a job process statistics in the \"job_process_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_job_process_stats(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: job process statistics. (required)
        :type body: JobProcessStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobProcessStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_job_process_stats_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_job_process_stats_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_job_process_stats_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[JobProcessStatsModel, Field(description="job process statistics.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a job process statistics.  # noqa: E501

        Store a job process statistics in the \"job_process_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_job_process_stats_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: job process statistics. (required)
        :type body: JobProcessStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobProcessStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_job_process_stats" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobProcessStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_process_stats', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_job_specifications(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[JobSpecificationsModel, Field(description="job definition to store in the collection.")],
        **kwargs,
    ) -> JobSpecificationsModel:
        """Store a job and create edges.  # noqa: E501

        Store a job in the \"jobs\" collection and create edges.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_job_specifications(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: job definition to store in the collection. (required)
        :type body: JobSpecificationsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobSpecificationsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_job_specifications_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_job_specifications_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_job_specifications_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[JobSpecificationsModel, Field(description="job definition to store in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a job and create edges.  # noqa: E501

        Store a job in the \"jobs\" collection and create edges.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_job_specifications_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: job definition to store in the collection. (required)
        :type body: JobSpecificationsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobSpecificationsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_job_specifications" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobSpecificationsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_specifications', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_jobs(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[JobsModel, Field(description="job.")],
        **kwargs,
    ) -> JobsModel:
        """Store a job.  # noqa: E501

        Store a job in the \"jobs\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_jobs(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: job. (required)
        :type body: JobsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_jobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_jobs_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_jobs_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[JobsModel, Field(description="job.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a job.  # noqa: E501

        Store a job in the \"jobs\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_jobs_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: job. (required)
        :type body: JobsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_jobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_jobs_key_complete_job_status_rev_run_id(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        status: Annotated[StrictStr, Field(description="New job status.")],
        rev: Annotated[StrictStr, Field(description="Current job revision.")],
        run_id: Annotated[StrictInt, Field(description="Current job run ID")],
        body: Annotated[ResultsModel, Field(description="Result of the job.")],
        **kwargs,
    ) -> JobsModel:
        """Complete a job and add a result.  # noqa: E501

        Complete a job, connect it to a result, and manage side effects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_jobs_key_complete_job_status_rev_run_id(workflow, key, status, rev, run_id, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param status: New job status. (required)
        :type status: str
        :param rev: Current job revision. (required)
        :type rev: str
        :param run_id: Current job run ID (required)
        :type run_id: int
        :param body: Result of the job. (required)
        :type body: ResultsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_jobs_key_complete_job_status_rev_run_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_jobs_key_complete_job_status_rev_run_id_with_http_info.raw_function(
            workflow,
            key,
            status,
            rev,
            run_id,
            body,
            **kwargs,
        )

    @validate_call
    def post_jobs_key_complete_job_status_rev_run_id_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        status: Annotated[StrictStr, Field(description="New job status.")],
        rev: Annotated[StrictStr, Field(description="Current job revision.")],
        run_id: Annotated[StrictInt, Field(description="Current job run ID")],
        body: Annotated[ResultsModel, Field(description="Result of the job.")],
        **kwargs,
    ) -> ApiResponse:
        """Complete a job and add a result.  # noqa: E501

        Complete a job, connect it to a result, and manage side effects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_jobs_key_complete_job_status_rev_run_id_with_http_info(workflow, key, status, rev, run_id, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param status: New job status. (required)
        :type status: str
        :param rev: Current job revision. (required)
        :type rev: str
        :param run_id: Current job run ID (required)
        :type run_id: int
        :param body: Result of the job. (required)
        :type body: ResultsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'status',
            'rev',
            'run_id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_jobs_key_complete_job_status_rev_run_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']

        if _params['status'] is not None:
            _path_params['status'] = _params['status']

        if _params['rev'] is not None:
            _path_params['rev'] = _params['rev']

        if _params['run_id'] is not None:
            _path_params['run_id'] = _params['run_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/complete_job/{status}/{rev}/{run_id}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_jobs_key_user_data(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        body: Annotated[UserDataModel, Field(description="User data for the job.")],
        **kwargs,
    ) -> UserDataModel:
        """Store user data for a job.  # noqa: E501

        Store user data for a job and connect the two vertexes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_jobs_key_user_data(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param body: User data for the job. (required)
        :type body: UserDataModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDataModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_jobs_key_user_data_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_jobs_key_user_data_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def post_jobs_key_user_data_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        body: Annotated[UserDataModel, Field(description="User data for the job.")],
        **kwargs,
    ) -> ApiResponse:
        """Store user data for a job.  # noqa: E501

        Store user data for a job and connect the two vertexes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_jobs_key_user_data_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param body: User data for the job. (required)
        :type body: UserDataModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDataModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_jobs_key_user_data" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDataModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/user_data', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_local_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[LocalSchedulersModel, Field(description="local compute node configuration.")],
        **kwargs,
    ) -> LocalSchedulersModel:
        """Store a local compute node configuration.  # noqa: E501

        Store a local compute node configuration in the \"local_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_local_schedulers(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: local compute node configuration. (required)
        :type body: LocalSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LocalSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_local_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_local_schedulers_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_local_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[LocalSchedulersModel, Field(description="local compute node configuration.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a local compute node configuration.  # noqa: E501

        Store a local compute node configuration in the \"local_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_local_schedulers_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: local compute node configuration. (required)
        :type body: LocalSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LocalSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_local_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/local_schedulers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_resource_requirements(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ResourceRequirementsModel, Field(description="resource requirements.")],
        **kwargs,
    ) -> ResourceRequirementsModel:
        """Store a resource requirements.  # noqa: E501

        Store a resource requirements in the \"resource_requirements\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_resource_requirements(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: resource requirements. (required)
        :type body: ResourceRequirementsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResourceRequirementsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_resource_requirements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_resource_requirements_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_resource_requirements_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ResourceRequirementsModel, Field(description="resource requirements.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a resource requirements.  # noqa: E501

        Store a resource requirements in the \"resource_requirements\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_resource_requirements_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: resource requirements. (required)
        :type body: ResourceRequirementsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResourceRequirementsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_resource_requirements" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRequirementsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/resource_requirements', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_results(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ResultsModel, Field(description="result.")],
        **kwargs,
    ) -> ResultsModel:
        """Store a result.  # noqa: E501

        Store a result in the \"results\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_results(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: result. (required)
        :type body: ResultsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResultsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_results_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_results_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_results_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ResultsModel, Field(description="result.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a result.  # noqa: E501

        Store a result in the \"results\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_results_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: result. (required)
        :type body: ResultsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResultsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_results" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/results', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_scheduled_compute_nodes(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ScheduledComputeNodesModel, Field(description="scheduled compute node.")],
        **kwargs,
    ) -> ScheduledComputeNodesModel:
        """Store a scheduled compute node.  # noqa: E501

        Store a scheduled compute node in the \"scheduled_compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_scheduled_compute_nodes(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: scheduled compute node. (required)
        :type body: ScheduledComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ScheduledComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_scheduled_compute_nodes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_scheduled_compute_nodes_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_scheduled_compute_nodes_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ScheduledComputeNodesModel, Field(description="scheduled compute node.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a scheduled compute node.  # noqa: E501

        Store a scheduled compute node in the \"scheduled_compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_scheduled_compute_nodes_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: scheduled compute node. (required)
        :type body: ScheduledComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ScheduledComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_scheduled_compute_nodes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/scheduled_compute_nodes', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_slurm_schedulers(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[SlurmSchedulersModel, Field(description="Slurm compute node configuration.")],
        **kwargs,
    ) -> SlurmSchedulersModel:
        """Store a Slurm compute node configuration.  # noqa: E501

        Store a Slurm compute node configuration in the \"slurm_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_slurm_schedulers(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: Slurm compute node configuration. (required)
        :type body: SlurmSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SlurmSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_slurm_schedulers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_slurm_schedulers_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_slurm_schedulers_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[SlurmSchedulersModel, Field(description="Slurm compute node configuration.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a Slurm compute node configuration.  # noqa: E501

        Store a Slurm compute node configuration in the \"slurm_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_slurm_schedulers_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: Slurm compute node configuration. (required)
        :type body: SlurmSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SlurmSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_slurm_schedulers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SlurmSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/slurm_schedulers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_user_data(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[UserDataModel, Field(description="user data.")],
        **kwargs,
    ) -> UserDataModel:
        """Store a user data.  # noqa: E501

        Store a user data in the \"user_data\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_user_data(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: user data. (required)
        :type body: UserDataModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDataModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_user_data_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_user_data_with_http_info.raw_function(
            workflow,
            body,
            **kwargs,
        )

    @validate_call
    def post_user_data_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[UserDataModel, Field(description="user data.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a user data.  # noqa: E501

        Store a user data in the \"user_data\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_user_data_with_http_info(workflow, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param body: user data. (required)
        :type body: UserDataModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDataModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_user_data" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDataModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/user_data', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflow_specifications(
        self,
        body: Annotated[WorkflowSpecificationsModel, Field(description="New workflow")],
        **kwargs,
    ) -> WorkflowsModel:
        """Store a workflow.  # noqa: E501

        Store a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflow_specifications(body, async_req=True)
        >>> result = thread.get()

        :param body: New workflow (required)
        :type body: WorkflowSpecificationsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflow_specifications_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflow_specifications_with_http_info.raw_function(
            body,
            **kwargs,
        )

    @validate_call
    def post_workflow_specifications_with_http_info(
        self,
        body: Annotated[WorkflowSpecificationsModel, Field(description="New workflow")],
        **kwargs,
    ) -> ApiResponse:
        """Store a workflow.  # noqa: E501

        Store a workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflow_specifications_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: New workflow (required)
        :type body: WorkflowSpecificationsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflow_specifications" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}

        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflow_specifications', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows(
        self,
        body: Annotated[WorkflowsModel, Field(description="Collection of jobs and dependent resources.")],
        **kwargs,
    ) -> WorkflowsModel:
        """Store a workflow.  # noqa: E501

        Store a workflow in the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows(body, async_req=True)
        >>> result = thread.get()

        :param body: Collection of jobs and dependent resources. (required)
        :type body: WorkflowsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_with_http_info.raw_function(
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_with_http_info(
        self,
        body: Annotated[WorkflowsModel, Field(description="Collection of jobs and dependent resources.")],
        **kwargs,
    ) -> ApiResponse:
        """Store a workflow.  # noqa: E501

        Store a workflow in the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: Collection of jobs and dependent resources. (required)
        :type body: WorkflowsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}

        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_auto_tune_resource_requirements(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Enable workflow for auto-tuning resource requirements.  # noqa: E501

        Enable workflow for auto-tuning resource requirements.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_auto_tune_resource_requirements(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_auto_tune_resource_requirements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_auto_tune_resource_requirements_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_auto_tune_resource_requirements_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Enable workflow for auto-tuning resource requirements.  # noqa: E501

        Enable workflow for auto-tuning resource requirements.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_auto_tune_resource_requirements_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_auto_tune_resource_requirements" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/auto_tune_resource_requirements', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_initialize_jobs(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        only_uninitialized: Annotated[Optional[StrictBool], Field(description="Only initialize jobs with a status of uninitialized.")] = None,
        clear_ephemeral_user_data: Annotated[Optional[StrictBool], Field(description="Clear all ephemeral user data.")] = None,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Initialize job relationships.  # noqa: E501

        Initialize job relationships based on file and user_data relationships.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_initialize_jobs(key, only_uninitialized, clear_ephemeral_user_data, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param only_uninitialized: Only initialize jobs with a status of uninitialized.
        :type only_uninitialized: bool
        :param clear_ephemeral_user_data: Clear all ephemeral user data.
        :type clear_ephemeral_user_data: bool
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_initialize_jobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_initialize_jobs_with_http_info.raw_function(
            key,
            only_uninitialized,
            clear_ephemeral_user_data,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_initialize_jobs_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        only_uninitialized: Annotated[Optional[StrictBool], Field(description="Only initialize jobs with a status of uninitialized.")] = None,
        clear_ephemeral_user_data: Annotated[Optional[StrictBool], Field(description="Clear all ephemeral user data.")] = None,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Initialize job relationships.  # noqa: E501

        Initialize job relationships based on file and user_data relationships.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_initialize_jobs_with_http_info(key, only_uninitialized, clear_ephemeral_user_data, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param only_uninitialized: Only initialize jobs with a status of uninitialized.
        :type only_uninitialized: bool
        :param clear_ephemeral_user_data: Clear all ephemeral user data.
        :type clear_ephemeral_user_data: bool
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'only_uninitialized',
            'clear_ephemeral_user_data',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_initialize_jobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('only_uninitialized') is not None:  # noqa: E501
            _query_params.append(('only_uninitialized', _params['only_uninitialized']))

        if _params.get('clear_ephemeral_user_data') is not None:  # noqa: E501
            _query_params.append(('clear_ephemeral_user_data', _params['clear_ephemeral_user_data']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/initialize_jobs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_join_by_inbound_edge_collection_edge(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        collection: Annotated[StrictStr, Field(description="From collection")],
        edge: Annotated[StrictStr, Field(description="Edge name")],
        body: Annotated[Dict[str, Any], Field(description="Filters for query")],
        collection_key: Optional[StrictStr] = None,
        collection_name: Optional[StrictStr] = None,
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> PostWorkflowsKeyJoinByInboundEdgeCollectionEdgeResponse:
        """Retrieve a joined table of two collections.  # noqa: E501

        Retrieve a table of the collections joined by an inbound edge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_join_by_inbound_edge_collection_edge(key, collection, edge, body, collection_key, collection_name, skip, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param collection: From collection (required)
        :type collection: str
        :param edge: Edge name (required)
        :type edge: str
        :param body: Filters for query (required)
        :type body: object
        :param collection_key:
        :type collection_key: str
        :param collection_name:
        :type collection_name: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostWorkflowsKeyJoinByInboundEdgeCollectionEdgeResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_join_by_inbound_edge_collection_edge_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_join_by_inbound_edge_collection_edge_with_http_info.raw_function(
            key,
            collection,
            edge,
            body,
            collection_key,
            collection_name,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_join_by_inbound_edge_collection_edge_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        collection: Annotated[StrictStr, Field(description="From collection")],
        edge: Annotated[StrictStr, Field(description="Edge name")],
        body: Annotated[Dict[str, Any], Field(description="Filters for query")],
        collection_key: Optional[StrictStr] = None,
        collection_name: Optional[StrictStr] = None,
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve a joined table of two collections.  # noqa: E501

        Retrieve a table of the collections joined by an inbound edge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_join_by_inbound_edge_collection_edge_with_http_info(key, collection, edge, body, collection_key, collection_name, skip, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param collection: From collection (required)
        :type collection: str
        :param edge: Edge name (required)
        :type edge: str
        :param body: Filters for query (required)
        :type body: object
        :param collection_key:
        :type collection_key: str
        :param collection_name:
        :type collection_name: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostWorkflowsKeyJoinByInboundEdgeCollectionEdgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'collection',
            'edge',
            'body',
            'collection_key',
            'collection_name',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_join_by_inbound_edge_collection_edge" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']

        if _params['collection'] is not None:
            _path_params['collection'] = _params['collection']

        if _params['edge'] is not None:
            _path_params['edge'] = _params['edge']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('collection_key') is not None:  # noqa: E501
            _query_params.append(('collection_key', _params['collection_key']))

        if _params.get('collection_name') is not None:  # noqa: E501
            _query_params.append(('collection_name', _params['collection_name']))

        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostWorkflowsKeyJoinByInboundEdgeCollectionEdgeResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/join_by_inbound_edge/{collection}/{edge}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_join_by_outbound_edge_collection_edge(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        collection: Annotated[StrictStr, Field(description="From collection")],
        edge: Annotated[StrictStr, Field(description="Edge name")],
        body: Annotated[Dict[str, Any], Field(description="Filters for query")],
        collection_key: Optional[StrictStr] = None,
        collection_name: Optional[StrictStr] = None,
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> PostWorkflowsKeyJoinByOutboundEdgeCollectionEdgeResponse:
        """Retrieve a joined table of two collections.  # noqa: E501

        Retrieve a table of the collections joined by an outbound edge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_join_by_outbound_edge_collection_edge(key, collection, edge, body, collection_key, collection_name, skip, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param collection: From collection (required)
        :type collection: str
        :param edge: Edge name (required)
        :type edge: str
        :param body: Filters for query (required)
        :type body: object
        :param collection_key:
        :type collection_key: str
        :param collection_name:
        :type collection_name: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostWorkflowsKeyJoinByOutboundEdgeCollectionEdgeResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_join_by_outbound_edge_collection_edge_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_join_by_outbound_edge_collection_edge_with_http_info.raw_function(
            key,
            collection,
            edge,
            body,
            collection_key,
            collection_name,
            skip,
            limit,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_join_by_outbound_edge_collection_edge_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        collection: Annotated[StrictStr, Field(description="From collection")],
        edge: Annotated[StrictStr, Field(description="Edge name")],
        body: Annotated[Dict[str, Any], Field(description="Filters for query")],
        collection_key: Optional[StrictStr] = None,
        collection_name: Optional[StrictStr] = None,
        skip: Optional[Union[StrictFloat, StrictInt]] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Retrieve a joined table of two collections.  # noqa: E501

        Retrieve a table of the collections joined by an outbound edge.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_join_by_outbound_edge_collection_edge_with_http_info(key, collection, edge, body, collection_key, collection_name, skip, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param collection: From collection (required)
        :type collection: str
        :param edge: Edge name (required)
        :type edge: str
        :param body: Filters for query (required)
        :type body: object
        :param collection_key:
        :type collection_key: str
        :param collection_name:
        :type collection_name: str
        :param skip:
        :type skip: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostWorkflowsKeyJoinByOutboundEdgeCollectionEdgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'collection',
            'edge',
            'body',
            'collection_key',
            'collection_name',
            'skip',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_join_by_outbound_edge_collection_edge" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']

        if _params['collection'] is not None:
            _path_params['collection'] = _params['collection']

        if _params['edge'] is not None:
            _path_params['edge'] = _params['edge']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('collection_key') is not None:  # noqa: E501
            _query_params.append(('collection_key', _params['collection_key']))

        if _params.get('collection_name') is not None:  # noqa: E501
            _query_params.append(('collection_name', _params['collection_name']))

        if _params.get('skip') is not None:  # noqa: E501
            _query_params.append(('skip', _params['skip']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostWorkflowsKeyJoinByOutboundEdgeCollectionEdgeResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/join_by_outbound_edge/{collection}/{edge}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_prepare_jobs_for_scheduling(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> PostWorkflowsKeyPrepareJobsForSchedulingResponse:
        """Return scheduler IDs that need to be activated.  # noqa: E501

        Return scheduler IDs that need to be activated. Sets job status to scheduled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_prepare_jobs_for_scheduling(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostWorkflowsKeyPrepareJobsForSchedulingResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_prepare_jobs_for_scheduling_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_prepare_jobs_for_scheduling_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_prepare_jobs_for_scheduling_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Return scheduler IDs that need to be activated.  # noqa: E501

        Return scheduler IDs that need to be activated. Sets job status to scheduled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_prepare_jobs_for_scheduling_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostWorkflowsKeyPrepareJobsForSchedulingResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_prepare_jobs_for_scheduling" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostWorkflowsKeyPrepareJobsForSchedulingResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/prepare_jobs_for_scheduling', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_prepare_jobs_for_submission(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ComputeNodesResources, Field(description="Available worker resources.")],
        sort_method: Optional[StrictStr] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> PostWorkflowsKeyPrepareJobsForSubmissionResponse:
        """Return ready jobs, accounting for resource requirements.  # noqa: E501

        Return jobs that are ready for submission and meet worker resource Sets status to submitted_pending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_prepare_jobs_for_submission(key, body, sort_method, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body: Available worker resources. (required)
        :type body: ComputeNodesResources
        :param sort_method:
        :type sort_method: str
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostWorkflowsKeyPrepareJobsForSubmissionResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_prepare_jobs_for_submission_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_prepare_jobs_for_submission_with_http_info.raw_function(
            key,
            body,
            sort_method,
            limit,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_prepare_jobs_for_submission_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[ComputeNodesResources, Field(description="Available worker resources.")],
        sort_method: Optional[StrictStr] = None,
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Return ready jobs, accounting for resource requirements.  # noqa: E501

        Return jobs that are ready for submission and meet worker resource Sets status to submitted_pending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_prepare_jobs_for_submission_with_http_info(key, body, sort_method, limit, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body: Available worker resources. (required)
        :type body: ComputeNodesResources
        :param sort_method:
        :type sort_method: str
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostWorkflowsKeyPrepareJobsForSubmissionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body',
            'sort_method',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_prepare_jobs_for_submission" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('sort_method') is not None:  # noqa: E501
            _query_params.append(('sort_method', _params['sort_method']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostWorkflowsKeyPrepareJobsForSubmissionResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/prepare_jobs_for_submission', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_prepare_next_jobs_for_submission(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> PostWorkflowsKeyPrepareNextJobsForSubmissionResponse:
        """Return user-requested number of ready jobs.  # noqa: E501

        Return user-requested number of jobs that are ready for submission. Sets status to submitted_pending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_prepare_next_jobs_for_submission(key, limit, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param limit:
        :type limit: float
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostWorkflowsKeyPrepareNextJobsForSubmissionResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_prepare_next_jobs_for_submission_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_prepare_next_jobs_for_submission_with_http_info.raw_function(
            key,
            limit,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_prepare_next_jobs_for_submission_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        limit: Optional[Union[StrictFloat, StrictInt]] = None,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Return user-requested number of ready jobs.  # noqa: E501

        Return user-requested number of jobs that are ready for submission. Sets status to submitted_pending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_prepare_next_jobs_for_submission_with_http_info(key, limit, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param limit:
        :type limit: float
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostWorkflowsKeyPrepareNextJobsForSubmissionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'limit',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_prepare_next_jobs_for_submission" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostWorkflowsKeyPrepareNextJobsForSubmissionResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/prepare_next_jobs_for_submission', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_process_auto_tune_resource_requirements_results(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Process the results of auto-tuning resource requirements.  # noqa: E501

        Process the results of auto-tuning resource requirements.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_process_auto_tune_resource_requirements_results(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_process_auto_tune_resource_requirements_results_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_process_auto_tune_resource_requirements_results_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_process_auto_tune_resource_requirements_results_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Process the results of auto-tuning resource requirements.  # noqa: E501

        Process the results of auto-tuning resource requirements.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_process_auto_tune_resource_requirements_results_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_process_auto_tune_resource_requirements_results" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/process_auto_tune_resource_requirements_results', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_process_changed_job_inputs(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> PostWorkflowsKeyProcessChangedJobInputsResponse:
        """Check for changed job inputs and update status accordingly.  # noqa: E501

        Check for changed job inputs and update status accordingly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_process_changed_job_inputs(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostWorkflowsKeyProcessChangedJobInputsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_process_changed_job_inputs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_process_changed_job_inputs_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_process_changed_job_inputs_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Check for changed job inputs and update status accordingly.  # noqa: E501

        Check for changed job inputs and update status accordingly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_process_changed_job_inputs_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostWorkflowsKeyProcessChangedJobInputsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_process_changed_job_inputs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostWorkflowsKeyProcessChangedJobInputsResponse",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/process_changed_job_inputs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_reset_job_status(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        failed_only: Annotated[Optional[StrictBool], Field(description="Only reset failed jobs")] = None,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Reset job status.  # noqa: E501

        Reset status for jobs to uninitialized.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_reset_job_status(key, failed_only, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param failed_only: Only reset failed jobs
        :type failed_only: bool
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_reset_job_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_reset_job_status_with_http_info.raw_function(
            key,
            failed_only,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_reset_job_status_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        failed_only: Annotated[Optional[StrictBool], Field(description="Only reset failed jobs")] = None,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Reset job status.  # noqa: E501

        Reset status for jobs to uninitialized.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_reset_job_status_with_http_info(key, failed_only, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param failed_only: Only reset failed jobs
        :type failed_only: bool
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'failed_only',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_reset_job_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('failed_only') is not None:  # noqa: E501
            _query_params.append(('failed_only', _params['failed_only']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/reset_job_status', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def post_workflows_key_reset_status(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Reset worklow status.  # noqa: E501

        Reset workflow status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_reset_status(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_workflows_key_reset_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.post_workflows_key_reset_status_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def post_workflows_key_reset_status_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Reset worklow status.  # noqa: E501

        Reset workflow status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_workflows_key_reset_status_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_workflows_key_reset_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/reset_status', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_aws_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the AWS compute node configuration.")],
        body: Annotated[AwsSchedulersModel, Field(description="AWS compute node configuration to update in the collection.")],
        **kwargs,
    ) -> AwsSchedulersModel:
        """Update AWS compute node configuration  # noqa: E501

        Update a document in the \"aws_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_aws_schedulers_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the AWS compute node configuration. (required)
        :type key: str
        :param body: AWS compute node configuration to update in the collection. (required)
        :type body: AwsSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AwsSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_aws_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_aws_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_aws_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the AWS compute node configuration.")],
        body: Annotated[AwsSchedulersModel, Field(description="AWS compute node configuration to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update AWS compute node configuration  # noqa: E501

        Update a document in the \"aws_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_aws_schedulers_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the AWS compute node configuration. (required)
        :type key: str
        :param body: AWS compute node configuration to update in the collection. (required)
        :type body: AwsSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AwsSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_aws_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AwsSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/aws_schedulers/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_compute_node_stats_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the compute node statistics.")],
        body: Annotated[ComputeNodeStatsModel, Field(description="compute node statistics to update in the collection.")],
        **kwargs,
    ) -> ComputeNodeStatsModel:
        """Update compute node statistics  # noqa: E501

        Update a document in the \"compute_node_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_compute_node_stats_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the compute node statistics. (required)
        :type key: str
        :param body: compute node statistics to update in the collection. (required)
        :type body: ComputeNodeStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodeStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_compute_node_stats_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_compute_node_stats_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_compute_node_stats_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the compute node statistics.")],
        body: Annotated[ComputeNodeStatsModel, Field(description="compute node statistics to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update compute node statistics  # noqa: E501

        Update a document in the \"compute_node_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_compute_node_stats_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the compute node statistics. (required)
        :type key: str
        :param body: compute node statistics to update in the collection. (required)
        :type body: ComputeNodeStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodeStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_compute_node_stats_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodeStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_node_stats/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_compute_nodes_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the compute node.")],
        body: Annotated[ComputeNodesModel, Field(description="compute node to update in the collection.")],
        **kwargs,
    ) -> ComputeNodesModel:
        """Update compute node  # noqa: E501

        Update a document in the \"compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_compute_nodes_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the compute node. (required)
        :type key: str
        :param body: compute node to update in the collection. (required)
        :type body: ComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_compute_nodes_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_compute_nodes_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_compute_nodes_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the compute node.")],
        body: Annotated[ComputeNodesModel, Field(description="compute node to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update compute node  # noqa: E501

        Update a document in the \"compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_compute_nodes_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the compute node. (required)
        :type key: str
        :param body: compute node to update in the collection. (required)
        :type body: ComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_compute_nodes_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/compute_nodes/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_events_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the event.")],
        body: Annotated[Dict[str, Any], Field(description="event to update in the collection.")],
        **kwargs,
    ) -> object:
        """Update event  # noqa: E501

        Update a document in the \"events\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_events_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the event. (required)
        :type key: str
        :param body: event to update in the collection. (required)
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_events_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_events_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_events_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the event.")],
        body: Annotated[Dict[str, Any], Field(description="event to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update event  # noqa: E501

        Update a document in the \"events\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_events_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the event. (required)
        :type key: str
        :param body: event to update in the collection. (required)
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_events_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/events/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_files_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the file.")],
        body: Annotated[FilesModel, Field(description="file to update in the collection.")],
        **kwargs,
    ) -> FilesModel:
        """Update file  # noqa: E501

        Update a document in the \"files\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_files_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the file. (required)
        :type key: str
        :param body: file to update in the collection. (required)
        :type body: FilesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FilesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_files_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_files_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_files_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the file.")],
        body: Annotated[FilesModel, Field(description="file to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update file  # noqa: E501

        Update a document in the \"files\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_files_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the file. (required)
        :type key: str
        :param body: file to update in the collection. (required)
        :type body: FilesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FilesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_files_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/files/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_job_process_stats_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the job process statistics.")],
        body: Annotated[JobProcessStatsModel, Field(description="job process statistics to update in the collection.")],
        **kwargs,
    ) -> JobProcessStatsModel:
        """Update job process statistics  # noqa: E501

        Update a document in the \"job_process_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_job_process_stats_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the job process statistics. (required)
        :type key: str
        :param body: job process statistics to update in the collection. (required)
        :type body: JobProcessStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobProcessStatsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_job_process_stats_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_job_process_stats_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_job_process_stats_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the job process statistics.")],
        body: Annotated[JobProcessStatsModel, Field(description="job process statistics to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update job process statistics  # noqa: E501

        Update a document in the \"job_process_stats\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_job_process_stats_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the job process statistics. (required)
        :type key: str
        :param body: job process statistics to update in the collection. (required)
        :type body: JobProcessStatsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobProcessStatsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_job_process_stats_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobProcessStatsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/job_process_stats/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_jobs_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the job.")],
        body: Annotated[JobsModel, Field(description="job to update in the collection.")],
        **kwargs,
    ) -> JobsModel:
        """Update job  # noqa: E501

        Update a document in the \"jobs\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_jobs_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the job. (required)
        :type key: str
        :param body: job to update in the collection. (required)
        :type body: JobsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_jobs_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_jobs_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_jobs_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the job.")],
        body: Annotated[JobsModel, Field(description="job to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update job  # noqa: E501

        Update a document in the \"jobs\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_jobs_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the job. (required)
        :type key: str
        :param body: job to update in the collection. (required)
        :type body: JobsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_jobs_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_jobs_key_manage_status_change_status_rev_run_id(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        status: Annotated[StrictStr, Field(description="New job status")],
        rev: Annotated[StrictStr, Field(description="Current job revision")],
        run_id: Annotated[StrictInt, Field(description="Current job run ID")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> JobsModel:
        """Change the status of a job and manage side effects.  # noqa: E501

        Change the status of a job and manage side effects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_jobs_key_manage_status_change_status_rev_run_id(workflow, key, status, rev, run_id, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param status: New job status (required)
        :type status: str
        :param rev: Current job revision (required)
        :type rev: str
        :param run_id: Current job run ID (required)
        :type run_id: int
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JobsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_jobs_key_manage_status_change_status_rev_run_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_jobs_key_manage_status_change_status_rev_run_id_with_http_info.raw_function(
            workflow,
            key,
            status,
            rev,
            run_id,
            body,
            **kwargs,
        )

    @validate_call
    def put_jobs_key_manage_status_change_status_rev_run_id_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        status: Annotated[StrictStr, Field(description="New job status")],
        rev: Annotated[StrictStr, Field(description="Current job revision")],
        run_id: Annotated[StrictInt, Field(description="Current job run ID")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Change the status of a job and manage side effects.  # noqa: E501

        Change the status of a job and manage side effects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_jobs_key_manage_status_change_status_rev_run_id_with_http_info(workflow, key, status, rev, run_id, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param status: New job status (required)
        :type status: str
        :param rev: Current job revision (required)
        :type rev: str
        :param run_id: Current job run ID (required)
        :type run_id: int
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JobsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'status',
            'rev',
            'run_id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_jobs_key_manage_status_change_status_rev_run_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']

        if _params['status'] is not None:
            _path_params['status'] = _params['status']

        if _params['rev'] is not None:
            _path_params['rev'] = _params['rev']

        if _params['run_id'] is not None:
            _path_params['run_id'] = _params['run_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/manage_status_change/{status}/{rev}/{run_id}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_jobs_key_resource_requirements_rr_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        rr_key: StrictStr,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> EdgesNameModel:
        """Set the resource requirements for a job.  # noqa: E501

        Set the resource requirements for a job, replacing any current value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_jobs_key_resource_requirements_rr_key(workflow, key, rr_key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param rr_key: (required)
        :type rr_key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EdgesNameModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_jobs_key_resource_requirements_rr_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_jobs_key_resource_requirements_rr_key_with_http_info.raw_function(
            workflow,
            key,
            rr_key,
            body,
            **kwargs,
        )

    @validate_call
    def put_jobs_key_resource_requirements_rr_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key")],
        key: Annotated[StrictStr, Field(description="Job key")],
        rr_key: StrictStr,
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Set the resource requirements for a job.  # noqa: E501

        Set the resource requirements for a job, replacing any current value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_jobs_key_resource_requirements_rr_key_with_http_info(workflow, key, rr_key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key (required)
        :type workflow: str
        :param key: Job key (required)
        :type key: str
        :param rr_key: (required)
        :type rr_key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EdgesNameModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'rr_key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_jobs_key_resource_requirements_rr_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']

        if _params['rr_key'] is not None:
            _path_params['rr_key'] = _params['rr_key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EdgesNameModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/jobs/{key}/resource_requirements/{rr_key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_local_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the local compute node configuration.")],
        body: Annotated[LocalSchedulersModel, Field(description="local compute node configuration to update in the collection.")],
        **kwargs,
    ) -> LocalSchedulersModel:
        """Update local compute node configuration  # noqa: E501

        Update a document in the \"local_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_local_schedulers_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the local compute node configuration. (required)
        :type key: str
        :param body: local compute node configuration to update in the collection. (required)
        :type body: LocalSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LocalSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_local_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_local_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_local_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the local compute node configuration.")],
        body: Annotated[LocalSchedulersModel, Field(description="local compute node configuration to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update local compute node configuration  # noqa: E501

        Update a document in the \"local_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_local_schedulers_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the local compute node configuration. (required)
        :type key: str
        :param body: local compute node configuration to update in the collection. (required)
        :type body: LocalSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LocalSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_local_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/local_schedulers/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_resource_requirements_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the resource requirements.")],
        body: Annotated[ResourceRequirementsModel, Field(description="resource requirements to update in the collection.")],
        **kwargs,
    ) -> ResourceRequirementsModel:
        """Update resource requirements  # noqa: E501

        Update a document in the \"resource_requirements\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_resource_requirements_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the resource requirements. (required)
        :type key: str
        :param body: resource requirements to update in the collection. (required)
        :type body: ResourceRequirementsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResourceRequirementsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_resource_requirements_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_resource_requirements_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_resource_requirements_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the resource requirements.")],
        body: Annotated[ResourceRequirementsModel, Field(description="resource requirements to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update resource requirements  # noqa: E501

        Update a document in the \"resource_requirements\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_resource_requirements_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the resource requirements. (required)
        :type key: str
        :param body: resource requirements to update in the collection. (required)
        :type body: ResourceRequirementsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResourceRequirementsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_resource_requirements_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRequirementsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/resource_requirements/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_results_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the result.")],
        body: Annotated[ResultsModel, Field(description="result to update in the collection.")],
        **kwargs,
    ) -> ResultsModel:
        """Update result  # noqa: E501

        Update a document in the \"results\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_results_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the result. (required)
        :type key: str
        :param body: result to update in the collection. (required)
        :type body: ResultsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResultsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_results_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_results_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_results_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the result.")],
        body: Annotated[ResultsModel, Field(description="result to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update result  # noqa: E501

        Update a document in the \"results\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_results_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the result. (required)
        :type key: str
        :param body: result to update in the collection. (required)
        :type body: ResultsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResultsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_results_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/results/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_scheduled_compute_nodes_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the scheduled compute node.")],
        body: Annotated[ScheduledComputeNodesModel, Field(description="scheduled compute node to update in the collection.")],
        **kwargs,
    ) -> ScheduledComputeNodesModel:
        """Update scheduled compute node  # noqa: E501

        Update a document in the \"scheduled_compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_scheduled_compute_nodes_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the scheduled compute node. (required)
        :type key: str
        :param body: scheduled compute node to update in the collection. (required)
        :type body: ScheduledComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ScheduledComputeNodesModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_scheduled_compute_nodes_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_scheduled_compute_nodes_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_scheduled_compute_nodes_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the scheduled compute node.")],
        body: Annotated[ScheduledComputeNodesModel, Field(description="scheduled compute node to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update scheduled compute node  # noqa: E501

        Update a document in the \"scheduled_compute_nodes\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_scheduled_compute_nodes_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the scheduled compute node. (required)
        :type key: str
        :param body: scheduled compute node to update in the collection. (required)
        :type body: ScheduledComputeNodesModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ScheduledComputeNodesModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_scheduled_compute_nodes_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledComputeNodesModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/scheduled_compute_nodes/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_slurm_schedulers_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the Slurm compute node configuration.")],
        body: Annotated[SlurmSchedulersModel, Field(description="Slurm compute node configuration to update in the collection.")],
        **kwargs,
    ) -> SlurmSchedulersModel:
        """Update Slurm compute node configuration  # noqa: E501

        Update a document in the \"slurm_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_slurm_schedulers_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the Slurm compute node configuration. (required)
        :type key: str
        :param body: Slurm compute node configuration to update in the collection. (required)
        :type body: SlurmSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SlurmSchedulersModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_slurm_schedulers_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_slurm_schedulers_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_slurm_schedulers_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the Slurm compute node configuration.")],
        body: Annotated[SlurmSchedulersModel, Field(description="Slurm compute node configuration to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update Slurm compute node configuration  # noqa: E501

        Update a document in the \"slurm_schedulers\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_slurm_schedulers_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the Slurm compute node configuration. (required)
        :type key: str
        :param body: Slurm compute node configuration to update in the collection. (required)
        :type body: SlurmSchedulersModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SlurmSchedulersModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_slurm_schedulers_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SlurmSchedulersModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/slurm_schedulers/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_user_data_key(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the user data.")],
        body: Annotated[UserDataModel, Field(description="user data to update in the collection.")],
        **kwargs,
    ) -> UserDataModel:
        """Update user data  # noqa: E501

        Update a document in the \"user_data\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_user_data_key(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the user data. (required)
        :type key: str
        :param body: user data to update in the collection. (required)
        :type body: UserDataModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserDataModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_user_data_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_user_data_key_with_http_info.raw_function(
            workflow,
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_user_data_key_with_http_info(
        self,
        workflow: Annotated[StrictStr, Field(description="Workflow key.")],
        key: Annotated[StrictStr, Field(description="key of the user data.")],
        body: Annotated[UserDataModel, Field(description="user data to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update user data  # noqa: E501

        Update a document in the \"user_data\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_user_data_key_with_http_info(workflow, key, body, async_req=True)
        >>> result = thread.get()

        :param workflow: Workflow key. (required)
        :type workflow: str
        :param key: key of the user data. (required)
        :type key: str
        :param body: user data to update in the collection. (required)
        :type body: UserDataModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserDataModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workflow',
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_user_data_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workflow'] is not None:
            _path_params['workflow'] = _params['workflow']

        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDataModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{workflow}/user_data/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_workflows_key(
        self,
        key: Annotated[StrictStr, Field(description="Key of the workflow.")],
        body: Annotated[WorkflowsModel, Field(description="workflow to update in the collection.")],
        **kwargs,
    ) -> WorkflowsModel:
        """Update workflow  # noqa: E501

        Update a document in the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Key of the workflow. (required)
        :type key: str
        :param body: workflow to update in the collection. (required)
        :type body: WorkflowsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowsModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_workflows_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_workflows_key_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_workflows_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Key of the workflow.")],
        body: Annotated[WorkflowsModel, Field(description="workflow to update in the collection.")],
        **kwargs,
    ) -> ApiResponse:
        """Update workflow  # noqa: E501

        Update a document in the \"workflows\" collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Key of the workflow. (required)
        :type key: str
        :param body: workflow to update in the collection. (required)
        :type body: WorkflowsModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowsModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workflows_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowsModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_workflows_key_cancel(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> object:
        """Cancel workflow.  # noqa: E501

        Cancel workflow. Workers will detect the status change and cancel jobs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key_cancel(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_workflows_key_cancel_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_workflows_key_cancel_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_workflows_key_cancel_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> ApiResponse:
        """Cancel workflow.  # noqa: E501

        Cancel workflow. Workers will detect the status change and cancel jobs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key_cancel_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workflows_key_cancel" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/cancel', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_workflows_key_config(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[WorkflowConfigModel, Field(description="Updated workflow config")],
        **kwargs,
    ) -> WorkflowConfigModel:
        """Updates the workflow config.  # noqa: E501

        Updates the workflow config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key_config(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body: Updated workflow config (required)
        :type body: WorkflowConfigModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowConfigModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_workflows_key_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_workflows_key_config_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_workflows_key_config_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[WorkflowConfigModel, Field(description="Updated workflow config")],
        **kwargs,
    ) -> ApiResponse:
        """Updates the workflow config.  # noqa: E501

        Updates the workflow config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key_config_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body: Updated workflow config (required)
        :type body: WorkflowConfigModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowConfigModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workflows_key_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowConfigModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/config', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def put_workflows_key_status(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[WorkflowStatusModel, Field(description="Updated workflow status")],
        **kwargs,
    ) -> WorkflowStatusModel:
        """Reports the workflow status.  # noqa: E501

        Reports the workflow status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key_status(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body: Updated workflow status (required)
        :type body: WorkflowStatusModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowStatusModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_workflows_key_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.put_workflows_key_status_with_http_info.raw_function(
            key,
            body,
            **kwargs,
        )

    @validate_call
    def put_workflows_key_status_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="Workflow key")],
        body: Annotated[WorkflowStatusModel, Field(description="Updated workflow status")],
        **kwargs,
    ) -> ApiResponse:
        """Reports the workflow status.  # noqa: E501

        Reports the workflow status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_workflows_key_status_with_http_info(key, body, async_req=True)
        >>> result = thread.get()

        :param key: Workflow key (required)
        :type key: str
        :param body: Updated workflow status (required)
        :type body: WorkflowStatusModel
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowStatusModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workflows_key_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['key'] is not None:
            _path_params['key'] = _params['key']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = []  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WorkflowStatusModel",
            '500': "InlineResponse500",
        }

        return self.api_client.call_api(
            '/workflows/{key}/status', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
