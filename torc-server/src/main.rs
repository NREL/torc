// This is the amended version that adds Authorization via Inversion of Control.

#![allow(missing_docs)]

use anyhow::Result;
use clap::Parser;
use dotenvy::dotenv;
use sqlx::sqlite::{SqliteConnectOptions, SqliteJournalMode, SqlitePoolOptions};
use std::env;
use std::str::FromStr;
use tracing::info;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
use tracing_timing::{Builder, Histogram};

mod server;

#[derive(Parser)]
#[command(name = "server")]
#[command(about = "Torc server")]
struct Args {
    /// Whether to use HTTPS or not
    #[arg(long)]
    https: bool,
    /// Defines the URL to use.
    #[arg(short, long, default_value = "localhost")]
    url: String,
    /// Defines the port to listen on.
    #[arg(short, long, default_value_t = 8080)]
    port: u16,
    /// Defines the number of threads to use.
    #[arg(short, long, default_value_t = 1)]
    threads: u32,
    /// Path to the SQLite database file. If not specified, uses DATABASE_URL environment variable.
    #[arg(short, long)]
    database: Option<String>,
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
fn main() -> Result<()> {
    dotenv().ok();

    let args = Args::parse();

    // Check if timing instrumentation should be enabled
    let timing_enabled = env::var("TORC_TIMING_ENABLED")
        .map(|v| v == "1" || v.to_lowercase() == "true")
        .unwrap_or(false);

    // Set up logging/tracing with optional timing
    if timing_enabled {
        // Set up tracing with timing layer
        let timing_layer = Builder::default()
            .no_span_recursion()
            .layer(|| Histogram::new_with_max(60_000_000_000, 2).unwrap());

        tracing_subscriber::registry()
            .with(
                tracing_subscriber::fmt::layer()
                    .with_target(true)
                    .with_level(true)
                    .with_span_events(tracing_subscriber::fmt::format::FmtSpan::CLOSE),
            )
            .with(
                tracing_subscriber::EnvFilter::try_from_default_env()
                    .unwrap_or_else(|_| "info".into()),
            )
            .with(timing_layer)
            .init();

        info!("Timing instrumentation enabled - timing data is being collected");
        info!(
            "Use external tools like tokio-console or OpenTelemetry exporters to view timing data"
        );
    } else {
        // When timing is disabled, use standard tracing with INFO level
        // Instrumented functions use debug level, so they won't appear in INFO logs
        tracing_subscriber::registry()
            .with(
                tracing_subscriber::fmt::layer()
                    .with_target(true)
                    .with_level(true),
            )
            .with(
                tracing_subscriber::EnvFilter::try_from_default_env()
                    .unwrap_or_else(|_| "info".into()),
            )
            .init();
    }

    // Use database path from command line if provided, otherwise fall back to DATABASE_URL env var
    let database_url = if let Some(db_path) = &args.database {
        format!("sqlite:{}", db_path)
    } else {
        env::var("DATABASE_URL").expect("DATABASE_URL must be set or --database must be provided")
    };

    // Build Tokio runtime with user-specified thread count
    let runtime = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(args.threads as usize)
        .enable_all()
        .build()?;

    runtime.block_on(async {
        // Configure SQLite connection with WAL journal mode for better concurrency
        // and foreign key constraints enabled
        let connect_options = SqliteConnectOptions::from_str(&database_url)?
            .journal_mode(SqliteJournalMode::Wal)
            .foreign_keys(true)
            .create_if_missing(true);

        let pool = SqlitePoolOptions::new()
            .connect_with(connect_options)
            .await?;

        info!("Connected to database: {}", database_url);
        info!("Database configured with WAL journal mode and foreign key constraints");

        // Run embedded migrations
        info!("Running database migrations...");
        sqlx::migrate!("../migrations")
            .run(&pool)
            .await
            .expect("Failed to run migrations");
        info!("Database migrations completed successfully");

        let addr = format!("{}:{}", args.url, args.port);
        info!(
            "Tokio runtime configured with {} worker threads",
            args.threads
        );
        info!("Listening on {}", addr);

        server::create(&addr, args.https, pool).await;
        Ok(())
    })
}
