// This is the amended version that adds Authorization via Inversion of Control.

#![allow(missing_docs)]

use anyhow::Result;
use clap::Parser;
use dotenvy::dotenv;
use sqlx::sqlite::{SqliteConnectOptions, SqliteJournalMode, SqlitePoolOptions};
use std::env;
use std::str::FromStr;
use tracing::info;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
use tracing_timing::{Builder, Histogram};

mod logging;
mod server;
mod service;

#[derive(Parser)]
#[command(name = "torc-server")]
#[command(about = "Torc workflow orchestration server")]
struct Args {
    #[command(subcommand)]
    command: Option<Commands>,

    /// Log level (error, warn, info, debug, trace)
    #[arg(long, default_value = "info", env = "RUST_LOG", global = true)]
    log_level: String,
    /// Whether to use HTTPS or not
    #[arg(long, global = true)]
    https: bool,
    /// Defines the URL to use.
    #[arg(short, long, default_value = "localhost", global = true)]
    url: String,
    /// Defines the port to listen on.
    #[arg(short, long, default_value_t = 8080, global = true)]
    port: u16,
    /// Defines the number of threads to use.
    #[arg(short, long, default_value_t = 1, global = true)]
    threads: u32,
    /// Path to the SQLite database file. If not specified, uses DATABASE_URL environment variable.
    #[arg(short, long, global = true)]
    database: Option<String>,
    /// Path to htpasswd file for basic authentication (username:bcrypt_hash format, one per line)
    #[arg(long, env = "TORC_AUTH_FILE", global = true)]
    auth_file: Option<String>,
    /// Require authentication for all requests (if false, auth is optional for backward compatibility)
    #[arg(long, default_value_t = false, global = true)]
    require_auth: bool,
    /// Directory for log files (enables file logging with size-based rotation)
    #[arg(long, env = "TORC_LOG_DIR", global = true)]
    log_dir: Option<std::path::PathBuf>,
    /// Use JSON format for log files (useful for log aggregation systems)
    #[arg(long, default_value_t = false, global = true)]
    json_logs: bool,
    /// Run as daemon (Unix/Linux only)
    #[arg(long, default_value_t = false, global = true)]
    daemon: bool,
    /// PID file location (Unix only, used when running as daemon)
    #[arg(long, default_value = "/var/run/torc-server.pid", global = true)]
    pid_file: std::path::PathBuf,
}

#[derive(clap::Subcommand)]
enum Commands {
    /// Run the server (default if no subcommand specified)
    Run,
    /// Manage system service (install, uninstall, start, stop, status)
    Service {
        #[command(subcommand)]
        action: ServiceAction,
    },
}

#[derive(clap::Subcommand)]
enum ServiceAction {
    /// Install the server as a system service
    Install {
        /// Install as user service (no root required)
        #[arg(long)]
        user: bool,
    },
    /// Uninstall the system service
    Uninstall {
        /// Uninstall user service
        #[arg(long)]
        user: bool,
    },
    /// Start the system service
    Start {
        /// Start user service
        #[arg(long)]
        user: bool,
    },
    /// Stop the system service
    Stop {
        /// Stop user service
        #[arg(long)]
        user: bool,
    },
    /// Check the status of the system service
    Status {
        /// Check user service status
        #[arg(long)]
        user: bool,
    },
}

/// Daemonize the process (Unix only)
#[cfg(unix)]
fn daemonize_process(pid_file: &std::path::Path) -> Result<()> {
    use daemonize::Daemonize;

    let daemonize = Daemonize::new()
        .pid_file(pid_file)
        .working_directory(env::current_dir()?)
        .umask(0o027);

    daemonize
        .start()
        .map_err(|e| anyhow::anyhow!("Failed to daemonize: {}", e))?;

    Ok(())
}

#[cfg(not(unix))]
fn daemonize_process(_pid_file: &std::path::Path) -> Result<()> {
    anyhow::bail!("Daemon mode is only supported on Unix/Linux systems");
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
fn main() -> Result<()> {
    dotenv().ok();

    let args = Args::parse();

    // Handle service management commands
    match args.command.as_ref().unwrap_or(&Commands::Run) {
        Commands::Service { action } => {
            let (command, user_level) = match action {
                ServiceAction::Install { user } => (service::ServiceCommand::Install, *user),
                ServiceAction::Uninstall { user } => (service::ServiceCommand::Uninstall, *user),
                ServiceAction::Start { user } => (service::ServiceCommand::Start, *user),
                ServiceAction::Stop { user } => (service::ServiceCommand::Stop, *user),
                ServiceAction::Status { user } => (service::ServiceCommand::Status, *user),
            };

            // For install command, pass the configuration from args
            let config = if matches!(command, service::ServiceCommand::Install) {
                Some(service::ServiceConfig {
                    log_dir: args.log_dir.clone(),
                    database: args.database.clone(),
                    url: args.url.clone(),
                    port: args.port,
                    threads: args.threads,
                    auth_file: args.auth_file.clone(),
                    require_auth: args.require_auth,
                    log_level: args.log_level.clone(),
                    json_logs: args.json_logs,
                })
            } else {
                None
            };

            return service::execute_service_command(command, config.as_ref(), user_level);
        }
        Commands::Run => {
            // Continue with normal server startup
        }
    }

    // Handle daemonization BEFORE initializing logging
    // This is important because daemonization forks the process
    if args.daemon {
        daemonize_process(&args.pid_file)?;
    }

    // Check if timing instrumentation should be enabled
    let timing_enabled = env::var("TORC_TIMING_ENABLED")
        .map(|v| v == "1" || v.to_lowercase() == "true")
        .unwrap_or(false);

    // Initialize logging with file rotation support
    if timing_enabled {
        // When timing is enabled, we need to set up tracing manually to include the timing layer
        // Set up tracing with timing layer
        let timing_layer = Builder::default()
            .no_span_recursion()
            .layer(|| Histogram::new_with_max(60_000_000_000, 2).unwrap());

        let env_filter = tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| args.log_level.clone().into());

        if let Some(ref log_dir) = args.log_dir {
            // File logging with timing (size-based rotation: 10 MiB, 5 files)
            let file_writer = logging::create_rotating_writer(log_dir)?;
            let (non_blocking, _guard) = tracing_appender::non_blocking(file_writer);
            std::mem::forget(_guard); // Keep guard alive

            tracing_subscriber::registry()
                .with(
                    tracing_subscriber::fmt::layer()
                        .with_target(true)
                        .with_level(true)
                        .with_span_events(tracing_subscriber::fmt::format::FmtSpan::CLOSE),
                )
                .with(
                    tracing_subscriber::fmt::layer()
                        .with_writer(non_blocking)
                        .with_ansi(false)
                        .with_target(true)
                        .with_level(true)
                        .with_span_events(tracing_subscriber::fmt::format::FmtSpan::CLOSE),
                )
                .with(env_filter)
                .with(timing_layer)
                .init();
        } else {
            // Console only with timing
            tracing_subscriber::registry()
                .with(
                    tracing_subscriber::fmt::layer()
                        .with_target(true)
                        .with_level(true)
                        .with_span_events(tracing_subscriber::fmt::format::FmtSpan::CLOSE),
                )
                .with(env_filter)
                .with(timing_layer)
                .init();
        }

        info!("Timing instrumentation enabled - timing data is being collected");
        if args.log_dir.is_some() {
            info!(
                "File logging configured with size-based rotation (10 MiB per file, 5 files max)"
            );
        }
        info!(
            "Use external tools like tokio-console or OpenTelemetry exporters to view timing data"
        );
    } else {
        // Use the new logging module for standard (non-timing) logging
        logging::init_logging(args.log_dir.as_deref(), &args.log_level, args.json_logs)?;
    }

    // Use database path from command line if provided, otherwise fall back to DATABASE_URL env var
    let database_url = if let Some(db_path) = &args.database {
        format!("sqlite:{}", db_path)
    } else {
        env::var("DATABASE_URL").expect("DATABASE_URL must be set or --database must be provided")
    };

    // Build Tokio runtime with user-specified thread count
    let runtime = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(args.threads as usize)
        .enable_all()
        .build()?;

    runtime.block_on(async {
        // Configure SQLite connection with WAL journal mode for better concurrency
        // and foreign key constraints enabled
        let connect_options = SqliteConnectOptions::from_str(&database_url)?
            .journal_mode(SqliteJournalMode::Wal)
            .foreign_keys(true)
            .create_if_missing(true);

        let pool = SqlitePoolOptions::new()
            .connect_with(connect_options)
            .await?;

        info!("Connected to database: {}", database_url);
        info!("Database configured with WAL journal mode and foreign key constraints");

        // Run embedded migrations
        info!("Running database migrations...");
        sqlx::migrate!("../migrations")
            .run(&pool)
            .await
            .expect("Failed to run migrations");
        info!("Database migrations completed successfully");

        // Load htpasswd file if provided
        let htpasswd = if let Some(auth_file_path) = &args.auth_file {
            info!("Loading htpasswd file from: {}", auth_file_path);
            match torc::server::htpasswd::HtpasswdFile::load(auth_file_path) {
                Ok(htpasswd) => {
                    info!("Loaded {} users from htpasswd file", htpasswd.user_count());
                    Some(htpasswd)
                }
                Err(e) => {
                    eprintln!("Error loading htpasswd file: {}", e);
                    std::process::exit(1);
                }
            }
        } else {
            if args.require_auth {
                eprintln!("Error: --require-auth specified but no --auth-file provided");
                std::process::exit(1);
            }
            info!("No htpasswd file configured, authentication disabled");
            None
        };

        if args.require_auth {
            info!("Authentication is REQUIRED for all requests");
        } else if htpasswd.is_some() {
            info!("Authentication is OPTIONAL (backward compatible mode)");
        }

        let addr = format!("{}:{}", args.url, args.port);
        info!(
            "Tokio runtime configured with {} worker threads",
            args.threads
        );
        info!("Listening on {}", addr);

        server::create(&addr, args.https, pool, htpasswd, args.require_auth).await;
        Ok(())
    })
}
