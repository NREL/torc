//! Main binary entry point for torc implementation.
// This is the amended version that adds Authorization via Inversion of Control.

#![allow(missing_docs)]

use anyhow::Result;
use clap::Parser;
use dotenvy::dotenv;
use log::{self, info};
use sqlx::sqlite::{SqliteConnectOptions, SqliteJournalMode, SqlitePoolOptions};
use std::env;
use std::str::FromStr;

mod server;

#[derive(Parser)]
#[command(name = "server")]
#[command(about = "Torc server")]
struct Args {
    /// Whether to use HTTPS or not
    #[arg(long)]
    https: bool,
    /// Defines the URL to use.
    #[arg(short, long, default_value = "localhost")]
    url: String,
    /// Defines the port to listen on.
    #[arg(short, long, default_value_t = 8080)]
    port: u16,
    /// Defines the number of threads to use.
    #[arg(short, long, default_value_t = 1)]
    threads: u32,
    /// Path to the SQLite database file. If not specified, uses DATABASE_URL environment variable.
    #[arg(short, long)]
    database: Option<String>,
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
fn main() -> Result<()> {
    dotenv().ok();
    env_logger::init();

    let args = Args::parse();

    // Use database path from command line if provided, otherwise fall back to DATABASE_URL env var
    let database_url = if let Some(db_path) = &args.database {
        format!("sqlite:{}", db_path)
    } else {
        env::var("DATABASE_URL").expect("DATABASE_URL must be set or --database must be provided")
    };

    // Build Tokio runtime with user-specified thread count
    let runtime = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(args.threads as usize)
        .enable_all()
        .build()?;

    runtime.block_on(async {
        // Configure SQLite connection with WAL journal mode for better concurrency
        // and foreign key constraints enabled
        let connect_options = SqliteConnectOptions::from_str(&database_url)?
            .journal_mode(SqliteJournalMode::Wal)
            .foreign_keys(true)
            .create_if_missing(true);

        let pool = SqlitePoolOptions::new()
            .connect_with(connect_options)
            .await?;

        info!("Connected to database: {}", database_url);
        info!("Database configured with WAL journal mode and foreign key constraints");

        // Run embedded migrations
        info!("Running database migrations...");
        sqlx::migrate!("../migrations")
            .run(&pool)
            .await
            .expect("Failed to run migrations");
        info!("Database migrations completed successfully");

        let addr = format!("{}:{}", args.url, args.port);
        info!(
            "Tokio runtime configured with {} worker threads",
            args.threads
        );
        info!("Listening on {}", addr);

        server::create(&addr, args.https, pool).await;
        Ok(())
    })
}
